<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>shengyayun's Notebook</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="shengyayun's Notebook" type="application/atom+xml">
</head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="/">shengyayun's Notebook</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="/">Home</a></li><li><a class="nav" href="/tags">Tags</a></li><li><a class="nav" href="/about">About</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> shengyayun 10 X 10</div></div><div id="code-pl">shengyayun:~$
<span class="code-pl-input">ssh shengyayun@tech</span><br><span class="code-pl-output">Welcome to shengyayun's Notebook.</span><br><br>shengyayun:~/blog$
<span class="code-pl-input">cat ./tags</span><br><a class="code-pl-output-url" href="/tags/#Seata"><span class="code-pl-output">Seata</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#collectd"><span class="code-pl-output">collectd</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#centos"><span class="code-pl-output">centos</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#docker"><span class="code-pl-output">docker</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#kubernetes"><span class="code-pl-output">kubernetes</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#grafana"><span class="code-pl-output">grafana</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#influxdb"><span class="code-pl-output">influxdb</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#java"><span class="code-pl-output">java</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#maven"><span class="code-pl-output">maven</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#manifest"><span class="code-pl-output">manifest</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#mysql"><span class="code-pl-output">mysql</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#mongodb"><span class="code-pl-output">mongodb</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#nacos"><span class="code-pl-output">nacos</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#nginx"><span class="code-pl-output">nginx</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#php"><span class="code-pl-output">php</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#prometheus"><span class="code-pl-output">prometheus</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#raft"><span class="code-pl-output">raft</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#swoole"><span class="code-pl-output">swoole</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#ssh"><span class="code-pl-output">ssh</span></a><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/tags/#voltdb"><span class="code-pl-output">voltdb</span></a><span class="code-pl-output"> </span><br><br>shengyayun:~/blog$
<span class="code-pl-input">ls post/part1</span><br><span class="code-pl-output">2022-02-25</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2022/02/25/tcc/" target="_blank"><span class="code-pl-output">分布式事务：TCC模式</span></a><br><span class="code-pl-output">2022-02-25</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2022/02/25/at/" target="_blank"><span class="code-pl-output">分布式事务：AT模式</span></a><br><span class="code-pl-output">2021-09-05</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2021/09/05/prometheus/" target="_blank"><span class="code-pl-output">Prometheus</span></a><br><span class="code-pl-output">2021-03-27</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2021/03/27/cheatsheet-for-ssh/" target="_blank"><span class="code-pl-output">SSH的常用指令</span></a><br><span class="code-pl-output">2020-05-02</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2020/05/02/nacos/" target="_blank"><span class="code-pl-output">部署一个单机模式的Nacos</span></a><br><span class="code-pl-output">2019-07-25</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2019/07/25/mysql-space/" target="_blank"><span class="code-pl-output">mysql表占用空间分析</span></a><br><span class="code-pl-output">2019-05-13</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2019/05/13/docker-stack-deploy/" target="_blank"><span class="code-pl-output">部署Docker容器到Kubernetes</span></a><br><span class="code-pl-output">2019-05-04</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2019/05/04/docker-registry/" target="_blank"><span class="code-pl-output">创建Docker私有仓库</span></a><br><span class="code-pl-output">2019-04-29</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2019/04/29/docker-build-image/" target="_blank"><span class="code-pl-output">通过Dockerfile生成镜像</span></a><br><span class="code-pl-output">2019-04-22</span><span class="code-pl-output"> </span><a class="code-pl-output-url" href="/2019/04/22/raft/" target="_blank"><span class="code-pl-output">Raft算法分析</span></a><br><br>shengyayun:~/blog$
<span class="code-pl-input">curl sites.list</span><br><a class="code-pl-output-url" href="https://www.google.com/" target="_blank"><span class="code-pl-output">Google</span></a><br><br></div></div></div></div></header><div id="content-outer"><div id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2022/02/25/tcc/">分布式事务：TCC模式</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-25</time><div class="article-inner"><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol>
<li>用户提交订单；</li>
<li>减少库存数量；</li>
</ol>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>Try：</strong>资源的检测和预留；<br><strong>Confirm：</strong>执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；<br><strong>Cancel：</strong>预留资源释放；<br><strong>幂等性：</strong>Confirm与Cancel必须实现幂等，因为如果执行失败，TC会不断重试。<br><strong>允许空回滚：</strong>Try未执行过的情况下，也可以Cancel成功。<br><strong>防悬挂控制：</strong>Cancel后Try被调用也不执行。</p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><img  src=http://www.plantuml.com/plantuml/svg/pPBDIiD058NtynJp0WLnMOWBKmGNXI9Pk1sRM8Bj9AGLwYuBBQLQB5f1Q_6F5hhHK1M4MF1bUcDz2vD9naoR6bowpBdddljnCjKzdPh48XLS85PDB-eceRK2KLMTbl3g2gh-pDUDkg3l67KyUtg0zeNNRqFh7fdnUZHGyal4hJpIgEflimHmp-7nSab2E8ZDuaoH4U8NS6RD_yvYcDZGSU1e16DxwXu7SOgCC_wKExDuzj65wvljpHn2aXJfeHTBqdmaPytYwUJkopuBbhZ6Jtel8sYSGBFXTPtef6Y98nJh8B6SCwZ624L09gAIPUoRs6jse7NxsJk4lkjTEGmvBEKNPDwOYCor56JH4aS4o8lBASW1cr1zWetTFkrCtK7Y3ub5oGRTrQrAfCSqeZvt7TwUmrWKl1F4kuF1UFOw_4_TRH2zdEYEYN_gpd-stdillJj2YrevMLqiBpONXhBclW40>
</div><div class="article-footer"><a class="article-more" href="/2022/02/25/tcc/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#Seata">Seata</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2022/02/25/at/">分布式事务：AT模式</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-25</time><div class="article-inner"><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol>
<li>用户提交订单；</li>
<li>减少库存数量；</li>
</ol>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>TC (Transaction Coordinator) - 事务协调者<br>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<p>TM (Transaction Manager) - 事务管理器<br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<p>RM (Resource Manager) - 资源管理器<br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><img  src=http://www.plantuml.com/plantuml/svg/AyxEp2j8B4hCLGX8B2h9JCuiICmh2KXCISdCIrSmCk0gXiixvLSWYNCbvLSel5Ytw6dlr6TpUfzsBUGgGEY7IeJuOX4CykLApKi1wWQRy7JNvAThPs0n0IA1K8mi5-BCnGMpGK7N3iYtKdYwf-7fXFLFMrSytTZmP5StoBWGPmLTe2nCfPN2Y_rJdiwU5-7fmiLbQmiLXwXLiBL5DHBcLYk59tiMl6oO1D844uDP-MppYgTjFL3Ba2KHcfzrBd-n49iIi7wmvBEE2K-xveCTY-9M9DUXAEHAByelBL20y9xFQdawPzUpcUl1FeA46GuVmG8KsKSmCQm-GfP4Q4Rn4OP-V3v2TXsgZq1EHueu3AU3ZUwVy6JN4epuHGbii18KIIHteqkYkctx9eW2Bb1wWuNnqoKRNsnPEYZ36E8q8i8Ogf2eC0PcZcUxP-4DOuWI766C8OaUnX05u3060000>
</div><div class="article-footer"><a class="article-more" href="/2022/02/25/at/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#Seata">Seata</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2021/09/05/prometheus/">Prometheus</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-05</time><div class="article-inner"><blockquote>
<p>Prometheusis an open-source systems monitoring and alerting toolkit originally built at SoundCloud.<br>普罗米修斯是最初由SoundCloud建立的一套开源的系统监控及预警的工具。</p>
</blockquote>
<p>[TOC]</p>
<h3 id="一-软件简介"><a href="#一-软件简介" class="headerlink" title="一. 软件简介"></a>一. 软件简介</h3><p>Prometheus 与 Influxdb都是时序数据库，比起关系型数据库，它们在时间序列数据的处理上具有极大的优势，例如长期高频率记录温度传感器的数值，该数据跟时间关联较大，且数据量极大。</p>
<h3 id="二-安装-Prometheus"><a href="#二-安装-Prometheus" class="headerlink" title="二. 安装 Prometheus"></a>二. 安装 Prometheus</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /opt 目录类似于Windows的C://Program Files/目录</span><br><span class="line">cd /opt/</span><br><span class="line"># 下载prometheus的压缩文件</span><br><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.29.1/prometheus-2.29.1.linux-amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar xzvf prometheus-2.29.1.linux-amd64.tar.gz</span><br><span class="line"># 创建软链接，便于后续进行版本升级</span><br><span class="line">ln -snf /opt/prometheus-2.29.1.linux-amd64.tar.gz /opt/prometheus</span><br></pre></td></tr></table></figure>

<h4 id="2-Systemd"><a href="#2-Systemd" class="headerlink" title="2. Systemd"></a>2. Systemd</h4><p>创建Service文件<code>vi /usr/lib/systemd/system/prometheus.service</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Prometheus</span><br><span class="line">After=network.target # 依赖于网络服务</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple # 启动类型：ExecStart 创建的进程作为主进程</span><br><span class="line">User=nobody # 执行用户使用 nobody</span><br><span class="line">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.path=/mnt/var/prometheus --web.console.libraries=/opt/prometheus/console_libraries --web.console.templates=/opt/prometheus/consoles --web.enable-lifecycle # 启动 prometheus 进程</span><br><span class="line">Restart=on-failure # 失败自动重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target # 可以通过 systemctl enable 启用，将会将该服务包含到 multi-user.target 中，这样在启动 multi-user.target 时，将会自动启动 multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用Systemd的Service的好处在于，可以开机自启动，并且失败可以自动重启，简化了运维管理。</p>
<p>重新加载Service文件：<code>systemctl daemon-reload</code><br>开机自启动：<code>systemctl enable prometheus</code><br>启动服务：<code>systemctl start prometheus</code><br>查看服务状态：<code>systemctl status prometheus</code><br>查看服务输出：<code>journalctl -xe -u prometheus</code></p>
</blockquote>
<h4 id="3-自带的图形化界面"><a href="#3-自带的图形化界面" class="headerlink" title="3. 自带的图形化界面"></a>3. 自带的图形化界面</h4><p>访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9090/graph">http://127.0.0.1:9090/graph</a></p>
<h3 id="三-安装-Exporter"><a href="#三-安装-Exporter" class="headerlink" title="三. 安装 Exporter"></a>三. 安装 Exporter</h3><blockquote>
<p>Prometheus 的官方与第三方提供了多种 Exporter，它们会采集各种监控数据，供Prometheus定期拉取（Pull）。</p>
</blockquote>
<h4 id="1-Node-Exporter（硬件与操作系统）"><a href="#1-Node-Exporter（硬件与操作系统）" class="headerlink" title="1. Node Exporter（硬件与操作系统）"></a>1. Node Exporter（硬件与操作系统）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.2.2/node_exporter-1.2.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p><code>vi /usr/lib/systemd/system/node_exporter.service</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=NodeExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">ExecStart=/opt/node_exporter/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><code>systemctl daemon-reload &amp; systemctl enable node_exporter &amp; systemctl start node_exporter</code></p>
<h4 id="2-Mysqld-Exporter（MySQL服务）"><a href="#2-Mysqld-Exporter（MySQL服务）" class="headerlink" title="2. Mysqld Exporter（MySQL服务）"></a>2. Mysqld Exporter（MySQL服务）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.13.0/mysqld_exporter-0.13.0.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p><code>vi /usr/lib/systemd/system/mysqld_exporter.service</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=MysqldExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Environment=DATA_SOURCE_NAME=user:password@(hostname:3306)/ # TODO Change</span><br><span class="line">ExecStart=/opt/mysqld_exporter/mysqld_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><code>systemctl daemon-reload &amp; systemctl enable mysqld_exporter &amp; systemctl start mysqld_exporter</code></p>
<h4 id="3-Kafka-Exporter"><a href="#3-Kafka-Exporter" class="headerlink" title="3. Kafka Exporter"></a>3. Kafka Exporter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/danielqsj/kafka_exporter/releases/download/v1.3.1/kafka_exporter-1.3.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p><code>vi /usr/lib/systemd/system/kafka_exporter.service</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=KafkaExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">ExecStart=/opt/mysqld_exporter/kafka_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><code>systemctl daemon-reload &amp; systemctl enable kafka_exporter &amp; systemctl start kafka_exporter</code></p>
<h3 id="四-Pull"><a href="#四-Pull" class="headerlink" title="四. Pull"></a>四. Pull</h3><blockquote>
<p>Prometheus 根据配置文件中的<code>scrape_configs</code>，自动定期拉从Exporter拉取数据。</p>
</blockquote>
<h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p><code>vi /opt/prometheus/prometheus.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 全局配置</span><br><span class="line">global:</span><br><span class="line">  scrape_interval: 15s # 每隔15s从Exporter拉取一次数据（根据scrape_configs）</span><br><span class="line">  evaluation_interval: 15s # 每隔15s计算一次规则（根据rule_files）</span><br><span class="line"></span><br><span class="line"># Alertmanager相关配置</span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets:</span><br><span class="line">          # - alertmanager:9093</span><br><span class="line"></span><br><span class="line"># 规则文件列表</span><br><span class="line">rule_files:</span><br><span class="line"></span><br><span class="line"># 抓取配置列表</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &quot;prometheus&quot; # 自带的Job，拉取Prometheus自身的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9090&quot;]</span><br><span class="line"></span><br><span class="line">## 以下为新增项</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;nodes&quot; # 拉取 Node Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9100&quot;] # Node Exporter 默认监听 9100 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;mysqld&quot; # 拉取 Mysqld Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9104&quot;] # Node Exporter 默认监听 9104 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;kafka&quot; # 拉取 Kafka Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9308&quot;] # Node Exporter 默认监听 9308 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;pushgateway&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9091&quot;] # PushGateway 默认监听 9091 端口</span><br></pre></td></tr></table></figure>
<h4 id="2-要求Prometheus重新加载配置文件"><a href="#2-要求Prometheus重新加载配置文件" class="headerlink" title="2. 要求Prometheus重新加载配置文件"></a>2. 要求Prometheus重新加载配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果未添加 -web.enable-lifecycle，这个接口会返回：Lifecycle API is not enabled</span><br><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure>


<h3 id="五-更好的可视化工具：Grafana"><a href="#五-更好的可视化工具：Grafana" class="headerlink" title="五. 更好的可视化工具：Grafana"></a>五. 更好的可视化工具：Grafana</h3><h4 id="1-安装并启动"><a href="#1-安装并启动" class="headerlink" title="1. 安装并启动"></a>1. 安装并启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-8.1.1-1.x86_64.rpm</span><br><span class="line">yum install grafana-8.1.1-1.x86_64.rpm</span><br><span class="line"></span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure>

<h4 id="2-初始管理员密码"><a href="#2-初始管理员密码" class="headerlink" title="2. 初始管理员密码"></a>2. 初始管理员密码</h4><p>访问 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a>, 默认账户为 admin:admin， admin首次登陆需要重设密码。</p>
<h4 id="3-数据源与模板"><a href="#3-数据源与模板" class="headerlink" title="3. 数据源与模板"></a>3. 数据源与模板</h4><p>添加Prometheus为数据源，然后去Grafana的<a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards?dataSource=prometheus" title="Dashboards">Dashboards</a>找一些合适的模板。</p>
<p><a target="_blank" rel="noopener" href="https://grafana.com/grafana/dashboards/8919" title="1 Node Exporter for Prometheus Dashboard CN v20201010">1 Node Exporter for Prometheus Dashboard CN v20201010</a>：</p>
</div><div class="article-footer"><a class="article-more" href="/2021/09/05/prometheus/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#centos">centos</a><a class="article-tag" href="/tags/#prometheus">prometheus</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2021/03/27/cheatsheet-for-ssh/">SSH的常用指令</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-27</time><div class="article-inner"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -m PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限设置</span></span><br><span class="line">chmod 700 .ssh </span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换OpenSSH格式</span></span><br><span class="line">puttygen id_rsa -o id_rsa.ppk</span><br><span class="line">puttygen id_rsa.ppk -O private-openssh -o id_rsa2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排查异常登录的IP使用的公钥</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/secure | grep 115.192.217.112</span><br><span class="line"><span class="comment"># Accepted publickey for root from 115.192.217.112 port 57305 ssh2: RSA SHA256:4egcXPHAIXpN7XxEiBQVV5dWEtQvi4JzbicrBJRZp1I</span></span><br><span class="line">ssh-keygen -lf ~/.ssh/authorized_keys | grep 4egcXPHAIXpN7XxEiBQVV5dWEtQvi4JzbicrBJRZp1I</span><br></pre></td></tr></table></figure></div><div class="article-footer"><a class="article-more" href="/2021/03/27/cheatsheet-for-ssh/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i></div></div></div><div class="recent-post-item"><a class="article-title" href="/2020/05/02/nacos/">部署一个单机模式的Nacos</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-02</time><div class="article-inner"><blockquote>
<p>部署于Centos7系统，需要额外安装MySQL、JDK8+。</p>
</blockquote>
<h2 id="一-MySQL"><a href="#一-MySQL" class="headerlink" title="一. MySQL"></a>一. MySQL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载Centos7使用的MySQL5.7</span></span><br><span class="line"><span class="comment"># 截止2020-05-03，Nacos最新版本不支持MySQL8+</span></span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum localinstall mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用MySQL服务</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从mysql日志中查找root的一次性密码</span></span><br><span class="line">grep password /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment"># 2020-05-02T02:37:53.274469Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: )jm8BYphsfa&gt;</span></span><br><span class="line"><span class="comment"># 发现系统默认生成的root密码为 )jm8BYphsfa&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新root密码，否则无法执行其他sql</span></span><br><span class="line">mysql -uroot -p<span class="string">&#x27;)jm8BYphsfa&gt;&#x27;</span></span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;一个很复杂很安全的密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Nacos需要的数据库</span></span><br><span class="line">create database nacos_db;</span><br></pre></td></tr></table></figure>

<h2 id="二-JDK8"><a href="#二-JDK8" class="headerlink" title="二. JDK8+"></a>二. JDK8+</h2><blockquote>
<p>不要忘记设置PATH、JAVA_HOME</p>
</blockquote>
<h2 id="三-Nacos"><a href="#三-Nacos" class="headerlink" title="三. Nacos"></a>三. Nacos</h2><blockquote>
<p>查找Nacos的最新的稳定包： <a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的文档包，这里是1.2.1</span></span><br><span class="line">wget https://github.com/alibaba/nacos/releases/download/1.2.1/nacos-server-1.2.1.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzvf nacos-server-1.2.1.tar.gz</span><br><span class="line"><span class="comment"># 将解压出的目录移动到/opt目录下（目录可自选）</span></span><br><span class="line">mv nacos /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Nacos的配置文件，</span></span><br><span class="line">vi /opt/nacos/conf/application.properties</span><br><span class="line"><span class="comment">##  涉及db.url.0、db.user、db.password。注意db.url.0中的数据库使用第一步中创建的nacos。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用单机模式的Nacos</span></span><br><span class="line">sh /opt/nacos/bin/startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>编辑Nacos的配置文件<code>vi /opt/nacos/conf/application.properties</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消MySQL相关的注释</span></span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line"><span class="comment"># 数据库使用步骤一中创建的数据库nacos_db</span></span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_db?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 不推荐使用root，可自行创建一个仅有nacos库读写权限的账户</span></span><br><span class="line">db.user=nacos_user</span><br><span class="line">db.password=nacos_passwd</span><br></pre></td></tr></table></figure>

<p>启动单机模式的Nacos：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /opt/nacos/bin/startup.sh -m standalone</span><br></pre></td></tr></table></figure>
</div><div class="article-footer"><a class="article-more" href="/2020/05/02/nacos/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#centos">centos</a><a class="article-tag" href="/tags/#nacos">nacos</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2019/07/25/mysql-space/">mysql表占用空间分析</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-25</time><div class="article-inner"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    table_schema, #库名</span><br><span class="line">    table_name, #表名</span><br><span class="line">    table_comment, #表注释</span><br><span class="line">    `engine`, #表引擎</span><br><span class="line">    ROUND(data_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Data&#x27;</span>,  #数据占用(MB)</span><br><span class="line">    ROUND(data_free <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Free&#x27;</span>, #碎片占用(MB)</span><br><span class="line">    ROUND(index_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Index&#x27;</span>, #索引占用(MB)</span><br><span class="line">    ROUND((data_length <span class="operator">+</span> data_free <span class="operator">+</span> index_length) <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Total&#x27;</span> #合计占用</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.tables</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_schema <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;mysql&#x27;</span> , <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;information_schema&#x27;</span>, <span class="string">&#x27;performance_schema&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_length <span class="operator">+</span> data_free <span class="operator">+</span> index_length <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div><div class="article-footer"><a class="article-more" href="/2019/07/25/mysql-space/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#mysql">mysql</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2019/05/13/docker-stack-deploy/">部署Docker容器到Kubernetes</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-13</time><div class="article-inner"><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part5/">Get Started, Part 5: Stacks</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">Compose file version 3 reference</a></p>
</blockquote>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>虽然docker默认的swarm与k8s（kubernetes）处于竞争关系，docker依然可以部署容器到k8s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure>

<h2 id="一-vi-compose-yml"><a href="#一-vi-compose-yml" class="headerlink" title="一. vi compose.yml"></a>一. vi compose.yml</h2><p>文件内容如下（保存前删除注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;                                        #compose file的版本，Docker Engine版本18.06.0+支持3.7</span><br><span class="line">services:                                             #service中运行的单个容器被称为task，系统中的单个模块被称为service</span><br><span class="line">  web:</span><br><span class="line">    image: localhost:5000/hello                       #使用私有镜像localhost:5000/hello（这里必须使用仓库中的，不可以用本地的）</span><br><span class="line">    deploy:                                           #部署操作</span><br><span class="line">      replicas: 5                                     #部署5个副本</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;                                 #每个副本最多使用10%的CPU时间片</span><br><span class="line">          memory: 50M                                 #每个副本最多使用50MB的RAM</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure                         #容器运行失败后自动重启</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;                                     #本地的4000端口映射到容器的80端口</span><br><span class="line">    redis:</span><br><span class="line">      image: redis                                    #docker hub上的redis镜像</span><br><span class="line">      ports:</span><br><span class="line">        - &quot;6379:6379&quot;                                 #本地的6379端口映射到容器的6379端口</span><br><span class="line">      volumes:</span><br><span class="line">        - &quot;/home/docker/data:/data&quot;                   #容器的/data目录挂载到本地的/home/docker/data目录（redis会将日志文件存储到/data目录）</span><br><span class="line">      deploy:</span><br><span class="line">        placement:</span><br><span class="line">          constraints: [node.role == manager]         #限制本service只在manager节点执行</span><br><span class="line">      command: redis-server --appendonly yes          #启动redis-server，同时指定数据持久化策略：AOF模式</span><br></pre></td></tr></table></figure>

<h2 id="二-docker-stack-deploy"><a href="#二-docker-stack-deploy" class="headerlink" title="二. docker stack deploy"></a>二. docker stack deploy</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service组成的完整的功能模块（甚至是系统）被称为stack。指定orchestrator为k8s，通过上一步保存的yml文件，生成名为hello的stack。</span></span><br><span class="line">docker stack deploy --orchestrator=kubernetes -c compose.yml hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看k8s的全部resources</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="comment"># 查看docker的全部stack</span></span><br><span class="line">docker stack ls</span><br></pre></td></tr></table></figure>
</div><div class="article-footer"><a class="article-more" href="/2019/05/13/docker-stack-deploy/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#centos">centos</a><a class="article-tag" href="/tags/#docker">docker</a><a class="article-tag" href="/tags/#kubernetes">kubernetes</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2019/05/04/docker-registry/">创建Docker私有仓库</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-04</time><div class="article-inner"><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/deploying/">Deploy a registry server</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/volumes/">Use volumes</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/bind-mounts/">Use bind mounts</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/garbage-collection/">Garbage collection</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/registry/spec/api/">HTTP API V2</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/glossary/?term=repository">Definition of: repository</a></p>
</blockquote>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>本文介绍如何在本地部署docker私有仓库，涉及到registry镜像（registry:2）、volume与bind（bind mount）、仓库的http api、仓库的垃圾回收等知识点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure>

<h2 id="一-创建一个volume"><a href="#一-创建一个volume" class="headerlink" title="一. 创建一个volume"></a>一. 创建一个volume</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个名为registry-vol的卷</span></span><br><span class="line">docker volume create registry-vol</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下指令，可以看到有一条VOLUME NAME为registry-vol的记录</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>
<p>与bind直接使用宿主的文件系统不同，volume由docker直接生成与管理，它跨系统、跨平台、易于备份与迁移。</p>
<h2 id="二-创建私有仓库"><a href="#二-创建私有仓库" class="headerlink" title="二. 创建私有仓库"></a>二. 创建私有仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从docker hub拉取私有仓库的镜像</span></span><br><span class="line">docker pull registry:2</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># -d 在后台运行容器</span></span><br><span class="line"><span class="comment"># -p 5000:5000 将本地的5000(冒号左边)端口映射到容器的5000(冒号右边)端口</span></span><br><span class="line"><span class="comment"># --mount src=registry-vol,dst=/var/lib/registry 将名为registry-vol的volume映射到容器的/var/lib/registry目录（通过volume的方式进行数据持久化）</span></span><br><span class="line"><span class="comment"># --restart=always 容器自动重启</span></span><br><span class="line"><span class="comment"># -e REGISTRY_STORAGE_DELETE_ENABLED=true 设置环境变量，使得私有仓库中的镜像可以被删除。</span></span><br><span class="line"><span class="comment"># registry:2 image:tag</span></span><br><span class="line">docker run -d -p 5000:5000 --mount <span class="built_in">type</span>=volume,src=registry-vol,dst=/var/lib/registry --restart=always -e REGISTRY_STORAGE_DELETE_ENABLED=<span class="literal">true</span> registry:2</span><br></pre></td></tr></table></figure>
<p>这里额外提供一个案例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># --mount type=bind,src=/mnt/registry,dst=/var/lib/registry 将本地的/mnt/registry映射到容器的/var/lib/registry目录（通过bind mount的方式进行数据持久化）</span></span><br><span class="line"><span class="comment"># -v `pwd`/config.yml:/etc/docker/registry/config.yml 将本地当前目录的config.yml文件映射到容器的/etc/docker/registry/config.yml。</span></span><br><span class="line">docker run -d -p 5000:5000 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/mnt/registry,dst=/var/lib/registry --restart=always -v `<span class="built_in">pwd</span>`/config.yml:/etc/docker/registry/config.yml registry:2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ol>
<li>第一个案例中的<code>-e REGISTRY_STORAGE_DELETE_ENABLED=true</code>，在第二个案例中可以通过在配置文件中添加<code>registry:storage:delete:enabled:true</code>来替代。</li>
<li>虽然-v的功能和–mount相似，但推荐使用较为冗长的–mount，因为它简单易懂。</li>
</ol>
<p>至此，私有仓库已经创建成功，我们可以通过docker提供的api确认一下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问私有仓库的接口</span></span><br><span class="line">curl http://localhost:5000/v2</span><br><span class="line"><span class="comment">#输出结果为&#123;&#125;，说明私有仓库已经在正常运行</span></span><br></pre></td></tr></table></figure>

<h2 id="三-推送镜像到私有仓库"><a href="#三-推送镜像到私有仓库" class="headerlink" title="三. 推送镜像到私有仓库"></a>三. 推送镜像到私有仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将本地镜像hello:latest（该镜像来自上个笔记）添加一个标签，其中localhost:5000对应私有仓库地址</span></span><br><span class="line">docker tag hello localhost:5000/hello</span><br><span class="line"><span class="comment">#docker根据tag，将镜像提交到私有仓库localhost:5000</span></span><br><span class="line">docker push localhost:5000/hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[&quot;hello&quot;]&#125;，说明已经提交成功。现在即使删除本地的镜像，也可以通过`docker pull localhost:5000/hello`从私有仓库重新获取。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>repository指的是一组Docker镜像。 repository可以通过推送到仓库服务来分享。同一个repository中的不同镜像可以通过标签来归类。</p>
</blockquote>
<p>hello镜像推送成功后，私有仓库会生成一个名为hello的repository。这个repository会存储各个tag的hello镜像，例如：hello:v1、hello:v2。</p>
<h2 id="四-搭建私有仓库的管理后台"><a href="#四-搭建私有仓库的管理后台" class="headerlink" title="四. 搭建私有仓库的管理后台"></a>四. 搭建私有仓库的管理后台</h2><p>对于私有仓库，docker只提供了http api的接口文档，它并未提供官方的管理后台。为了方便学习，采用第三方提供的<a target="_blank" rel="noopener" href="https://github.com/Joxit/docker-registry-ui">Joxit/docker-registry-ui</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull joxit/docker-registry-ui:static</span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># -p 5050:80 将本地的5050端口映射到容器的80端口</span></span><br><span class="line"><span class="comment"># -e REGISTRY_URL=http://172.17.0.1:5000 通过环境变量设置容器访问的仓库地址为 http://172.17.0.1:5000</span></span><br><span class="line"><span class="comment"># -e DELETE_IMAGES=true 通过环境变量设置镜像可删除</span></span><br><span class="line"><span class="comment"># -e REGISTRY_TITLE=&quot;My registry&quot; 通过环境变量设置后台的title</span></span><br><span class="line">docker run -d -p 5050:80 -e REGISTRY_URL=http://172.17.0.1:5000 -e DELETE_IMAGES=<span class="literal">true</span> -e REGISTRY_TITLE=<span class="string">&quot;My registry&quot;</span> joxit/docker-registry-ui:static</span><br></pre></td></tr></table></figure>
<p>这里的REGISTRY_UR并不是 <a target="_blank" rel="noopener" href="http://localhost:5000/">http://localhost:5000</a> ，因为容器和本机的localhost并不等价。通过以下方式取得在对应的docker网络中本机的局域网地址：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后台容器采用默认的bridge网络， 查询该网络的详细属性</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line"><span class="comment">#输出结果中发现IPAM.Config.Gateway为172.17.0.1，这就是本机在bridge网络中的局域网地址了。</span></span><br></pre></td></tr></table></figure>
<p>通过浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:5050/">http://localhost:5050</a> ，可以通过管理后台对私有仓库进行管理了。</p>
<h2 id="五-删除私有仓库中的hello"><a href="#五-删除私有仓库中的hello" class="headerlink" title="五. 删除私有仓库中的hello"></a>五. 删除私有仓库中的hello</h2><p>通过后台页面，找到删除功能并不复杂。但是即使删除成功，后台的repository列表中依然存在hello（虽然再也无法拉取镜像）。这并不是管理后台的问题，下面通过接口确认：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[&quot;hello&quot;]&#125;，hello的repository依然存在</span></span><br></pre></td></tr></table></figure>
<p>查阅资料，发现官方指出：</p>
<ol>
<li>目前的api只能删除repository中的镜像，而不能删除repository本身。</li>
<li>私有仓库提供的api只能删除manifests（清单）和layers（层）。所以repository一旦被创建，将无法通过api将其彻底删除。</li>
<li>api中的删除操作会移除对目标的引用，使得其可以被垃圾回收。同时让它无法被api访问。</li>
<li>垃圾回收会清理不被任何manifests（清单）引用的数据块，数据块包含layers（层）或manifests（清单）。当manifests（清单）被删除时，它指向的layers（层）中没被其他清单引用的也会被删除。</li>
</ol>
<p>也就是说之前通过api删除的，只是repository下的hello:latest镜像，而repository本身依然存在。<br>想要删除repository，需要通过一种stop-the-world（清理期间上传中的镜像可能会被误删）的方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找私有仓库的容器ID</span></span><br><span class="line">docker container ls | grep registry:2</span><br><span class="line"><span class="comment">#容器执行指令</span></span><br><span class="line"><span class="comment"># exec 让容器执行指令</span></span><br><span class="line"><span class="comment"># -it i为交互，t为分配一个冒充的tty</span></span><br><span class="line"><span class="comment"># 74252955fbd9 私有仓库的容器ID，替换为实际ID</span></span><br><span class="line"><span class="comment"># /bin/sh 让容器执行的指令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 74252955fbd9 /bin/sh <span class="comment">#执行后可以直接通过shell操作容器了</span></span><br><span class="line"><span class="comment">#进行垃圾回收</span></span><br><span class="line"><span class="comment"># 垃圾回收会清理不被任何manifests（清单）引用的数据块，数据块包含layers（层）或manifests（清单）</span></span><br><span class="line"><span class="comment"># 当manifests（清单）被删除时，它指向的layers（层）中没被其他清单引用的也会被删除</span></span><br><span class="line">/bin/registry garbage-collect /etc/docker/registry/config.yml</span><br><span class="line"><span class="comment">#删除hello的repository</span></span><br><span class="line">rm -rf /var/lib/registry/docker/registry/v2/repositories/hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[]&#125;，说明已经hello已经被彻底删除</span></span><br></pre></td></tr></table></figure>
</div><div class="article-footer"><a class="article-more" href="/2019/05/04/docker-registry/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#centos">centos</a><a class="article-tag" href="/tags/#docker">docker</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2019/04/29/docker-build-image/">通过Dockerfile生成镜像</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-29</time><div class="article-inner"><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/">Get Started, Part 2: Containers</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></p>
</blockquote>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>这里将通过一个简单的场景来学习Dockerfile的使用：制作一个安装了openresty的centos的镜像（image）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure>

<h2 id="一-创建一个工作目录"><a href="#一-创建一个工作目录" class="headerlink" title="一. 创建一个工作目录"></a>一. 创建一个工作目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后续这个目录将存放Dockerfile和entrypoint.sh</span></span><br><span class="line">mkdir hello</span><br></pre></td></tr></table></figure>

<h2 id="二-在工作目录中创建一个Dockerfile文件"><a href="#二-在工作目录中创建一个Dockerfile文件" class="headerlink" title="二. 在工作目录中创建一个Dockerfile文件"></a>二. 在工作目录中创建一个Dockerfile文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像，并且必须是第一条指令（如果不需要基础镜像，那么替换为 FROM scratch）</span></span><br><span class="line"><span class="comment"># 这里的centos是镜像名，7是标签。这里对应系统centos 7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器的工作路径，对后续的RUN, CMD, ENTRYPOINT, COPY, ADD生效（如果对应的目录不存在则会创建，可以重复设置）</span></span><br><span class="line"><span class="comment"># 这里会在容器中创建一个/app文件夹，下面的对应操作会在/app中进行</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地拷贝文件到容器</span></span><br><span class="line"><span class="comment"># 这里会把本地的demo目录内的全部文件拷贝到容器的/app目录下（./指当前目录，而当前目录通过WORKDIR定义）</span></span><br><span class="line">COPY * ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器在build时执行指令</span></span><br><span class="line">RUN yum install -y lsof git</span><br><span class="line">RUN yum install -y yum-utils</span><br><span class="line">RUN yum-config-manager -y --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line">RUN yum install -y openresty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动时执行指令，CMD命令的功能类似，但主要区别在于CMD可被dock run的COMMAND参数覆盖，而ENTRYPOINT不会</span></span><br><span class="line"><span class="comment"># 如果CMD或ENTRYPOINT配置了多条，且CMD指令不是完整的可执行命令，那么CMD的内容将成为ENTRYPOINT的参数。反之仅最后一条生效。</span></span><br><span class="line"><span class="comment"># 当容器启动时会执行/app/entrypoint.sh文件（build的时候不会执行），该文件在上面的COPY操作中被docker从本地的工作目录拷贝到了容器的/app目录</span></span><br><span class="line">ENTRYPOINT ./entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外开放端口</span></span><br><span class="line"><span class="comment"># 若果不将80端口对外暴露，容器外将无法访问容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>

<h2 id="三-在工作目录中创建一个entrypoint-sh文件"><a href="#三-在工作目录中创建一个entrypoint-sh文件" class="headerlink" title="三. 在工作目录中创建一个entrypoint.sh文件"></a>三. 在工作目录中创建一个entrypoint.sh文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动openresty服务</span></span><br><span class="line">openresty</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker会将没有前台守护进程的容器直接关闭，所以这里通过本指令阻塞脚本的执行</span></span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure>
<p>文件生成完成后，记得还要通过<code>chmod +x entrypoint.sh</code>给脚本加上执行权限，否则容器启动时将无法执行脚本。</p>
<h2 id="四-在工作目录下build镜像"><a href="#四-在工作目录下build镜像" class="headerlink" title="四. 在工作目录下build镜像"></a>四. 在工作目录下build镜像</h2><blockquote>
<p>Usage:    docker build [OPTIONS] PATH | URL | -</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待生成镜像的name为hello，tag为缺省值latest，路径为.（当前工作目录）</span></span><br><span class="line">docker build -t hello .</span><br><span class="line"><span class="comment"># 指令执行完成后，控制台输出镜像完整的ID</span></span><br></pre></td></tr></table></figure>
<p>执行<code>docker image ls</code>，docker会打印出本地存储的全部镜像，其中REPOSITORY为hello，TAG为latest的记录对应刚创建的镜像。</p>
<h2 id="五-创建容器"><a href="#五-创建容器" class="headerlink" title="五. 创建容器"></a>五. 创建容器</h2><blockquote>
<p>Usage:    docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 该容器在后台执行</span></span><br><span class="line"><span class="comment"># -p 4000:80 将容器的80端口映射到本地的4000端口（通过localhost:4000访问容器的openresty的80端口）。</span></span><br><span class="line"><span class="comment"># hello 使用镜像hello</span></span><br><span class="line">docker run -d -p 4000:80 hello</span><br><span class="line"><span class="comment"># 指令执行完成后，控制台输出容器完整的ID</span></span><br></pre></td></tr></table></figure>
<p>执行<code>docker container ls</code>，docker会打印出本地执行中的全部容器，其中IMAGE为hello的记录对应刚启动的容器。<br>打开浏览器访问<code>http://localhost:4000</code>，可以看到openrestry的默认主页，至此镜像及其对应的容器已创建完成。</p>
</div><div class="article-footer"><a class="article-more" href="/2019/04/29/docker-build-image/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#centos">centos</a><a class="article-tag" href="/tags/#docker">docker</a></div></div></div><div class="recent-post-item"><a class="article-title" href="/2019/04/22/raft/">Raft算法分析</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-22</time><div class="article-inner"><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>Raft算法用于保证分布式系统的强一致性，被目前知名的etcd所采用。</p>
<h2 id="一-心跳"><a href="#一-心跳" class="headerlink" title="一. 心跳"></a>一. 心跳</h2><p>集群中每个节点都需要定期向其他节点发送心跳包，如果超过一半的节点超过一定时间(阈值)未收到该节点的心跳包，那么认定该节点已下线。</p>
<img  src=http://www.plantuml.com/plantuml/svg/Uz7LzBnffwE2ZQwTmWimsybAuUd-vXVRDtFbvPUaAXHbfcUK08Ncxtgogo-ZfAJWvTJzB_RFUzQtzFcibkAIejJ4tESRTp-Tr_soOTRBnibSBp0CT8ORY2ddWaVE5KtE2O-PJdZCTC9ZfZCUVSJAePlfWaqE0000>


<h2 id="二-选举"><a href="#二-选举" class="headerlink" title="二. 选举"></a>二. 选举</h2><p>集群中节点角色可为Leader、Follower或Candidate其中一个。当Follower在一定时间内没有收到来自Leader的心跳，会将自己角色变更为Candidate，然后等待一段随机的时间后，发起选举。</p>
<img  src=http://www.plantuml.com/plantuml/svg/dLPDKzfG55sJNy6uqd5STEl26MljgZ_13JDagZCCT2ZJkkIZV8DW5R0OeBNWM9GlYn2Co8zfxajOzI_qlhmG0m6jBc0Wxxvpppltt7Upw_RuUBld4--rgucW4XnisjVjxtY7a_Skov94XCgwUuNRdOrwZL5lFIwNvpFlvHmkdvsKQcgqpZOgnIym2gdztv0AgxqmAVGusmHyRMFV1649cvjeo-5sxZaTFfwpkJoU3vpDDbbRsp25AOqut8V7nGmHRX5iNEXYf8RdtNk_wyE8SM04uJHKYx9ODq0Xcy9eo1ogD_snFowBzuiIi1ZbienXV-zIkZohg-xPFAIL8LS_p90OFWuDvRkYslp5zgs-mbsQSiSzYBLH07KKXNI2vDge7qkwZCgGv1KA2_tEYdfJ9h4iHT8WyJSaAWXY9Rjba6MXQgjFEa4QEYs7QL4M9VKyWFaWUqc4AwJFLf4BuokB1xAOGE6842Uv67k8gqJmatoR56emAj2_twEGwJ-mshAlJMcejceMu3GvQJ4OF1n9VbMaaeKhX7kob6Su85mWHLq5eQv8HwIaKGc58N8ZYqbsTlasWf3ut2Y1FAX0kqEpnVrg-mYNbbWr8NAjr0DBSyLyir3CoVh-z17Xj0pLzCJHSn2tdq3Sdj4C_DzeuAW4ZHDwp5oRf9ie6pHJ9DTzH3Dj7yD1wq7sqAmYoMJb-rFcBOgQRpzUw1ttJAcLkpoM6jERKMMfHXfLY5L9lc7ER_16zI5xpgZ_yMkdVghfRRph8s_7Ih-qLQ3QKRkrPxRA0lzgo2yqodz3FTSX-Z4r5rEV3oFG6f3yW1MFd7PfTSLZLW73DWy4fcoZfo2DdzXe35aM6mnMJsbkC5dqgyEcqMPOqnqtd0T9MT23ZKutsXoVK3Znc7aQSHWdmoIK76E1lYM976Egr2uUSunbQaqfk-3sOxSepOTpA7ghpnVDSBhqewXoaKG1cFaMpJb4KAGOQPmP8sJ-37aSPU7PZ5bhwV5CImqDgR8Q91nKhAZBnbFZneNCoOf-8Ku0p5rireP9phkTdFP5Fzh4Dq0dZNy0pHoENYfLu0nlGFFGdpVpEMtyMTDIBsYsD0GqzjEN4tO6w5-pUv-RezZcb69QCQrfaEV2DudfIbfYA3vj3r7adgoNhja_>


<h2 id="三-强一致"><a href="#三-强一致" class="headerlink" title="三. 强一致"></a>三. 强一致</h2><p>假设集群中最多n台机器发生故障，那么最少需要2n+1个节点。比起在拜占庭问题中最少需要3n+1个节点，raft协议的优势在于节点不存在欺骗问题。</p>
<img  src=http://www.plantuml.com/plantuml/svg/bPBFIiD04CRlFaNeIG--W0V1YwVUlNWH35Ke3PI2rneKGqX8n9fAJKaBJV6GHW-IDar2NcPdDZTVmPMDQFD7wctPcT_CDzyC7RoWiXJs3uN6iTHkIrTYDrDbAeUx9FBs6iA1WC_lQBtXWquIUwSwYT5DyUpy-vT1MUA1SPz36x5oxibH4uSkfCDIOfqaC3LSk3dKaNgYqBriNVHOX4vzaewpu3PBxyYg3xfAHpUS_WsXOeBgr4rJbbZ1RhIjB4JY4IWpj1QSPefmx38vl0nxa2X2sy6dLp3dNr7R-OYrqmw40LaDS1AYxgFjeJT5moJhsGyQMs0iyzfpcIIFMPg0EgbniJ0BtoTL0-nVextUslGYjxLv1J3txtzj-IM1hp7wZywKNtCLzGa0>
</div><div class="article-footer"><a class="article-more" href="/2019/04/22/raft/#more">more>></a><div class="article-tags"><i class="fa fa-tag" aria-hidden="true"></i><a class="article-tag" href="/tags/#raft">raft</a></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"><a class="social-icon" href="https://github.com/shengyayun" target="_blank"><i class="fa fa-github"></i></a></div><p class="design-info">Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://github.com/lazysheep666/terminal_theme" target="_blank">Teminal</a> (<a href="https://github.com/Tonny-Gu/terminal_theme" target="_blank">NekoDaemon Remix</a>)</p><p class="design-info"><a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a> 
Licensed | Copyright © 2022 shengyayun</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>