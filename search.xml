<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式事务：TCC模式</title>
      <link href="/2022/02/25/tcc/"/>
      <url>/2022/02/25/tcc/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol><li>用户提交订单；</li><li>减少库存数量；</li></ol><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>Try：</strong>资源的检测和预留；<br><strong>Confirm：</strong>执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；<br><strong>Cancel：</strong>预留资源释放；<br><strong>幂等性：</strong>Confirm与Cancel必须实现幂等，因为如果执行失败，TC会不断重试。<br><strong>允许空回滚：</strong>Try未执行过的情况下，也可以Cancel成功。<br><strong>防悬挂控制：</strong>Cancel后Try被调用也不执行。</p><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><img  src=http://www.plantuml.com/plantuml/svg/pPBDIiD058NtynJp0WLnMOWBKmGNXI9Pk1sRM8Bj9AGLwYuBBQLQB5f1Q_6F5hhHK1M4MF1bUcDz2vD9naoR6bowpBdddljnCjKzdPh48XLS85PDB-eceRK2KLMTbl3g2gh-pDUDkg3l67KyUtg0zeNNRqFh7fdnUZHGyal4hJpIgEflimHmp-7nSab2E8ZDuaoH4U8NS6RD_yvYcDZGSU1e16DxwXu7SOgCC_wKExDuzj65wvljpHn2aXJfeHTBqdmaPytYwUJkopuBbhZ6Jtel8sYSGBFXTPtef6Y98nJh8B6SCwZ624L09gAIPUoRs6jse7NxsJk4lkjTEGmvBEKNPDwOYCor56JH4aS4o8lBASW1cr1zWetTFkrCtK7Y3ub5oGRTrQrAfCSqeZvt7TwUmrWKl1F4kuF1UFOw_4_TRH2zdEYEYN_gpd-stdillJj2YrevMLqiBpONXhBclW40>]]></content>
      
      
      
        <tags>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务：AT模式</title>
      <link href="/2022/02/25/at/"/>
      <url>/2022/02/25/at/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol><li>用户提交订单；</li><li>减少库存数量；</li></ol><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>TC (Transaction Coordinator) - 事务协调者<br>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p><p>TM (Transaction Manager) - 事务管理器<br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p><p>RM (Resource Manager) - 资源管理器<br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><img  src=http://www.plantuml.com/plantuml/svg/AyxEp2j8B4hCLGX8B2h9JCuiICmh2KXCISdCIrSmCk0gXiixvLSWYNCbvLSel5Ytw6dlr6TpUfzsBUGgGEY7IeJuOX4CykLApKi1wWQRy7JNvAThPs0n0IA1K8mi5-BCnGMpGK7N3iYtKdYwf-7fXFLFMrSytTZmP5StoBWGPmLTe2nCfPN2Y_rJdiwU5-7fmiLbQmiLXwXLiBL5DHBcLYk59tiMl6oO1D844uDP-MppYgTjFL3Ba2KHcfzrBd-n49iIi7wmvBEE2K-xveCTY-9M9DUXAEHAByelBL20y9xFQdawPzUpcUl1FeA46GuVmG8KsKSmCQm-GfP4Q4Rn4OP-V3v2TXsgZq1EHueu3AU3ZUwVy6JN4epuHGbii18KIIHteqkYkctx9eW2Bb1wWuNnqoKRNsnPEYZ36E8q8i8Ogf2eC0PcZcUxP-4DOuWI766C8OaUnX05u3060000>]]></content>
      
      
      
        <tags>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus</title>
      <link href="/2021/09/05/prometheus/"/>
      <url>/2021/09/05/prometheus/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Prometheusis an open-source systems monitoring and alerting toolkit originally built at SoundCloud.<br>普罗米修斯是最初由SoundCloud建立的一套开源的系统监控及预警的工具。</p></blockquote><p>[TOC]</p><h3 id="一-软件简介"><a href="#一-软件简介" class="headerlink" title="一. 软件简介"></a>一. 软件简介</h3><p>Prometheus 与 Influxdb都是时序数据库，比起关系型数据库，它们在时间序列数据的处理上具有极大的优势，例如长期高频率记录温度传感器的数值，该数据跟时间关联较大，且数据量极大。</p><h3 id="二-安装-Prometheus"><a href="#二-安装-Prometheus" class="headerlink" title="二. 安装 Prometheus"></a>二. 安装 Prometheus</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /opt 目录类似于Windows的C://Program Files/目录</span><br><span class="line">cd /opt/</span><br><span class="line"># 下载prometheus的压缩文件</span><br><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.29.1/prometheus-2.29.1.linux-amd64.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar xzvf prometheus-2.29.1.linux-amd64.tar.gz</span><br><span class="line"># 创建软链接，便于后续进行版本升级</span><br><span class="line">ln -snf /opt/prometheus-2.29.1.linux-amd64.tar.gz /opt/prometheus</span><br></pre></td></tr></table></figure><h4 id="2-Systemd"><a href="#2-Systemd" class="headerlink" title="2. Systemd"></a>2. Systemd</h4><p>创建Service文件<code>vi /usr/lib/systemd/system/prometheus.service</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Prometheus</span><br><span class="line">After=network.target # 依赖于网络服务</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple # 启动类型：ExecStart 创建的进程作为主进程</span><br><span class="line">User=nobody # 执行用户使用 nobody</span><br><span class="line">ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus/prometheus.yml --storage.tsdb.path=/mnt/var/prometheus --web.console.libraries=/opt/prometheus/console_libraries --web.console.templates=/opt/prometheus/consoles --web.enable-lifecycle # 启动 prometheus 进程</span><br><span class="line">Restart=on-failure # 失败自动重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target # 可以通过 systemctl enable 启用，将会将该服务包含到 multi-user.target 中，这样在启动 multi-user.target 时，将会自动启动 multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>使用Systemd的Service的好处在于，可以开机自启动，并且失败可以自动重启，简化了运维管理。</p><p>重新加载Service文件：<code>systemctl daemon-reload</code><br>开机自启动：<code>systemctl enable prometheus</code><br>启动服务：<code>systemctl start prometheus</code><br>查看服务状态：<code>systemctl status prometheus</code><br>查看服务输出：<code>journalctl -xe -u prometheus</code></p></blockquote><h4 id="3-自带的图形化界面"><a href="#3-自带的图形化界面" class="headerlink" title="3. 自带的图形化界面"></a>3. 自带的图形化界面</h4><p>访问 <a href="http://127.0.0.1:9090/graph">http://127.0.0.1:9090/graph</a></p><h3 id="三-安装-Exporter"><a href="#三-安装-Exporter" class="headerlink" title="三. 安装 Exporter"></a>三. 安装 Exporter</h3><blockquote><p>Prometheus 的官方与第三方提供了多种 Exporter，它们会采集各种监控数据，供Prometheus定期拉取（Pull）。</p></blockquote><h4 id="1-Node-Exporter（硬件与操作系统）"><a href="#1-Node-Exporter（硬件与操作系统）" class="headerlink" title="1. Node Exporter（硬件与操作系统）"></a>1. Node Exporter（硬件与操作系统）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.2.2/node_exporter-1.2.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p><code>vi /usr/lib/systemd/system/node_exporter.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=NodeExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">ExecStart=/opt/node_exporter/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><code>systemctl daemon-reload &amp; systemctl enable node_exporter &amp; systemctl start node_exporter</code></p><h4 id="2-Mysqld-Exporter（MySQL服务）"><a href="#2-Mysqld-Exporter（MySQL服务）" class="headerlink" title="2. Mysqld Exporter（MySQL服务）"></a>2. Mysqld Exporter（MySQL服务）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.13.0/mysqld_exporter-0.13.0.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p><code>vi /usr/lib/systemd/system/mysqld_exporter.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=MysqldExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Environment=DATA_SOURCE_NAME=user:password@(hostname:3306)/ # TODO Change</span><br><span class="line">ExecStart=/opt/mysqld_exporter/mysqld_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><code>systemctl daemon-reload &amp; systemctl enable mysqld_exporter &amp; systemctl start mysqld_exporter</code></p><h4 id="3-Kafka-Exporter"><a href="#3-Kafka-Exporter" class="headerlink" title="3. Kafka Exporter"></a>3. Kafka Exporter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/danielqsj/kafka_exporter/releases/download/v1.3.1/kafka_exporter-1.3.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p><code>vi /usr/lib/systemd/system/kafka_exporter.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=KafkaExporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">ExecStart=/opt/mysqld_exporter/kafka_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><code>systemctl daemon-reload &amp; systemctl enable kafka_exporter &amp; systemctl start kafka_exporter</code></p><h3 id="四-Pull"><a href="#四-Pull" class="headerlink" title="四. Pull"></a>四. Pull</h3><blockquote><p>Prometheus 根据配置文件中的<code>scrape_configs</code>，自动定期拉从Exporter拉取数据。</p></blockquote><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h4><p><code>vi /opt/prometheus/prometheus.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 全局配置</span><br><span class="line">global:</span><br><span class="line">  scrape_interval: 15s # 每隔15s从Exporter拉取一次数据（根据scrape_configs）</span><br><span class="line">  evaluation_interval: 15s # 每隔15s计算一次规则（根据rule_files）</span><br><span class="line"></span><br><span class="line"># Alertmanager相关配置</span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">    - static_configs:</span><br><span class="line">        - targets:</span><br><span class="line">          # - alertmanager:9093</span><br><span class="line"></span><br><span class="line"># 规则文件列表</span><br><span class="line">rule_files:</span><br><span class="line"></span><br><span class="line"># 抓取配置列表</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &quot;prometheus&quot; # 自带的Job，拉取Prometheus自身的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9090&quot;]</span><br><span class="line"></span><br><span class="line">## 以下为新增项</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;nodes&quot; # 拉取 Node Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9100&quot;] # Node Exporter 默认监听 9100 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;mysqld&quot; # 拉取 Mysqld Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9104&quot;] # Node Exporter 默认监听 9104 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;kafka&quot; # 拉取 Kafka Exporter 的数据</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9308&quot;] # Node Exporter 默认监听 9308 端口</span><br><span class="line"></span><br><span class="line">  - job_name: &quot;pushgateway&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9091&quot;] # PushGateway 默认监听 9091 端口</span><br></pre></td></tr></table></figure><h4 id="2-要求Prometheus重新加载配置文件"><a href="#2-要求Prometheus重新加载配置文件" class="headerlink" title="2. 要求Prometheus重新加载配置文件"></a>2. 要求Prometheus重新加载配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果未添加 -web.enable-lifecycle，这个接口会返回：Lifecycle API is not enabled</span><br><span class="line">curl -X POST http://localhost:9090/-/reload</span><br></pre></td></tr></table></figure><h3 id="五-更好的可视化工具：Grafana"><a href="#五-更好的可视化工具：Grafana" class="headerlink" title="五. 更好的可视化工具：Grafana"></a>五. 更好的可视化工具：Grafana</h3><h4 id="1-安装并启动"><a href="#1-安装并启动" class="headerlink" title="1. 安装并启动"></a>1. 安装并启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-8.1.1-1.x86_64.rpm</span><br><span class="line">yum install grafana-8.1.1-1.x86_64.rpm</span><br><span class="line"></span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure><h4 id="2-初始管理员密码"><a href="#2-初始管理员密码" class="headerlink" title="2. 初始管理员密码"></a>2. 初始管理员密码</h4><p>访问 <a href="http://localhost:3000/">http://localhost:3000</a>, 默认账户为 admin:admin， admin首次登陆需要重设密码。</p><h4 id="3-数据源与模板"><a href="#3-数据源与模板" class="headerlink" title="3. 数据源与模板"></a>3. 数据源与模板</h4><p>添加Prometheus为数据源，然后去Grafana的<a href="https://grafana.com/grafana/dashboards?dataSource=prometheus" title="Dashboards">Dashboards</a>找一些合适的模板。</p><p><a href="https://grafana.com/grafana/dashboards/8919" title="1 Node Exporter for Prometheus Dashboard CN v20201010">1 Node Exporter for Prometheus Dashboard CN v20201010</a>：</p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH的常用指令</title>
      <link href="/2021/03/27/cheatsheet-for-ssh/"/>
      <url>/2021/03/27/cheatsheet-for-ssh/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -m PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限设置</span></span><br><span class="line">chmod 700 .ssh </span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换OpenSSH格式</span></span><br><span class="line">puttygen id_rsa -o id_rsa.ppk</span><br><span class="line">puttygen id_rsa.ppk -O private-openssh -o id_rsa2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排查异常登录的IP使用的公钥</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/secure | grep 115.192.217.112</span><br><span class="line"><span class="comment"># Accepted publickey for root from 115.192.217.112 port 57305 ssh2: RSA SHA256:4egcXPHAIXpN7XxEiBQVV5dWEtQvi4JzbicrBJRZp1I</span></span><br><span class="line">ssh-keygen -lf ~/.ssh/authorized_keys | grep 4egcXPHAIXpN7XxEiBQVV5dWEtQvi4JzbicrBJRZp1I</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>部署一个单机模式的Nacos</title>
      <link href="/2020/05/02/nacos/"/>
      <url>/2020/05/02/nacos/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部署于Centos7系统，需要额外安装MySQL、JDK8+。</p></blockquote><h2 id="一-MySQL"><a href="#一-MySQL" class="headerlink" title="一. MySQL"></a>一. MySQL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载Centos7使用的MySQL5.7</span></span><br><span class="line"><span class="comment"># 截止2020-05-03，Nacos最新版本不支持MySQL8+</span></span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum localinstall mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用MySQL服务</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从mysql日志中查找root的一次性密码</span></span><br><span class="line">grep password /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment"># 2020-05-02T02:37:53.274469Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: )jm8BYphsfa&gt;</span></span><br><span class="line"><span class="comment"># 发现系统默认生成的root密码为 )jm8BYphsfa&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新root密码，否则无法执行其他sql</span></span><br><span class="line">mysql -uroot -p<span class="string">&#x27;)jm8BYphsfa&gt;&#x27;</span></span><br><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;一个很复杂很安全的密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Nacos需要的数据库</span></span><br><span class="line">create database nacos_db;</span><br></pre></td></tr></table></figure><h2 id="二-JDK8"><a href="#二-JDK8" class="headerlink" title="二. JDK8+"></a>二. JDK8+</h2><blockquote><p>不要忘记设置PATH、JAVA_HOME</p></blockquote><h2 id="三-Nacos"><a href="#三-Nacos" class="headerlink" title="三. Nacos"></a>三. Nacos</h2><blockquote><p>查找Nacos的最新的稳定包： <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载最新的文档包，这里是1.2.1</span></span><br><span class="line">wget https://github.com/alibaba/nacos/releases/download/1.2.1/nacos-server-1.2.1.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzvf nacos-server-1.2.1.tar.gz</span><br><span class="line"><span class="comment"># 将解压出的目录移动到/opt目录下（目录可自选）</span></span><br><span class="line">mv nacos /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Nacos的配置文件，</span></span><br><span class="line">vi /opt/nacos/conf/application.properties</span><br><span class="line"><span class="comment">##  涉及db.url.0、db.user、db.password。注意db.url.0中的数据库使用第一步中创建的nacos。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用单机模式的Nacos</span></span><br><span class="line">sh /opt/nacos/bin/startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>编辑Nacos的配置文件<code>vi /opt/nacos/conf/application.properties</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消MySQL相关的注释</span></span><br><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line"><span class="comment"># 数据库使用步骤一中创建的数据库nacos_db</span></span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_db?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 不推荐使用root，可自行创建一个仅有nacos库读写权限的账户</span></span><br><span class="line">db.user=nacos_user</span><br><span class="line">db.password=nacos_passwd</span><br></pre></td></tr></table></figure><p>启动单机模式的Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /opt/nacos/bin/startup.sh -m standalone</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql表占用空间分析</title>
      <link href="/2019/07/25/mysql-space/"/>
      <url>/2019/07/25/mysql-space/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    table_schema, #库名</span><br><span class="line">    table_name, #表名</span><br><span class="line">    table_comment, #表注释</span><br><span class="line">    `engine`, #表引擎</span><br><span class="line">    ROUND(data_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Data&#x27;</span>,  #数据占用(MB)</span><br><span class="line">    ROUND(data_free <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Free&#x27;</span>, #碎片占用(MB)</span><br><span class="line">    ROUND(index_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Index&#x27;</span>, #索引占用(MB)</span><br><span class="line">    ROUND((data_length <span class="operator">+</span> data_free <span class="operator">+</span> index_length) <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span>) <span class="keyword">AS</span> <span class="string">&#x27;Total&#x27;</span> #合计占用</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    information_schema.tables</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    table_schema <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;mysql&#x27;</span> , <span class="string">&#x27;sys&#x27;</span>, <span class="string">&#x27;information_schema&#x27;</span>, <span class="string">&#x27;performance_schema&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> data_length <span class="operator">+</span> data_free <span class="operator">+</span> index_length <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Docker容器到Kubernetes</title>
      <link href="/2019/05/13/docker-stack-deploy/"/>
      <url>/2019/05/13/docker-stack-deploy/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/get-started/part5/">Get Started, Part 5: Stacks</a><br><a href="https://docs.docker.com/compose/compose-file/">Compose file version 3 reference</a></p></blockquote><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>虽然docker默认的swarm与k8s（kubernetes）处于竞争关系，docker依然可以部署容器到k8s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure><h2 id="一-vi-compose-yml"><a href="#一-vi-compose-yml" class="headerlink" title="一. vi compose.yml"></a>一. vi compose.yml</h2><p>文件内容如下（保存前删除注释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;                                        #compose file的版本，Docker Engine版本18.06.0+支持3.7</span><br><span class="line">services:                                             #service中运行的单个容器被称为task，系统中的单个模块被称为service</span><br><span class="line">  web:</span><br><span class="line">    image: localhost:5000/hello                       #使用私有镜像localhost:5000/hello（这里必须使用仓库中的，不可以用本地的）</span><br><span class="line">    deploy:                                           #部署操作</span><br><span class="line">      replicas: 5                                     #部署5个副本</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;                                 #每个副本最多使用10%的CPU时间片</span><br><span class="line">          memory: 50M                                 #每个副本最多使用50MB的RAM</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure                         #容器运行失败后自动重启</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;                                     #本地的4000端口映射到容器的80端口</span><br><span class="line">    redis:</span><br><span class="line">      image: redis                                    #docker hub上的redis镜像</span><br><span class="line">      ports:</span><br><span class="line">        - &quot;6379:6379&quot;                                 #本地的6379端口映射到容器的6379端口</span><br><span class="line">      volumes:</span><br><span class="line">        - &quot;/home/docker/data:/data&quot;                   #容器的/data目录挂载到本地的/home/docker/data目录（redis会将日志文件存储到/data目录）</span><br><span class="line">      deploy:</span><br><span class="line">        placement:</span><br><span class="line">          constraints: [node.role == manager]         #限制本service只在manager节点执行</span><br><span class="line">      command: redis-server --appendonly yes          #启动redis-server，同时指定数据持久化策略：AOF模式</span><br></pre></td></tr></table></figure><h2 id="二-docker-stack-deploy"><a href="#二-docker-stack-deploy" class="headerlink" title="二. docker stack deploy"></a>二. docker stack deploy</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service组成的完整的功能模块（甚至是系统）被称为stack。指定orchestrator为k8s，通过上一步保存的yml文件，生成名为hello的stack。</span></span><br><span class="line">docker stack deploy --orchestrator=kubernetes -c compose.yml hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看k8s的全部resources</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="comment"># 查看docker的全部stack</span></span><br><span class="line">docker stack ls</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> docker </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建Docker私有仓库</title>
      <link href="/2019/05/04/docker-registry/"/>
      <url>/2019/05/04/docker-registry/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/registry/deploying/">Deploy a registry server</a><br><a href="https://docs.docker.com/storage/volumes/">Use volumes</a><br><a href="https://docs.docker.com/storage/bind-mounts/">Use bind mounts</a><br><a href="https://docs.docker.com/registry/garbage-collection/">Garbage collection</a><br><a href="https://docs.docker.com/registry/spec/api/">HTTP API V2</a><br><a href="https://docs.docker.com/glossary/?term=repository">Definition of: repository</a></p></blockquote><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>本文介绍如何在本地部署docker私有仓库，涉及到registry镜像（registry:2）、volume与bind（bind mount）、仓库的http api、仓库的垃圾回收等知识点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure><h2 id="一-创建一个volume"><a href="#一-创建一个volume" class="headerlink" title="一. 创建一个volume"></a>一. 创建一个volume</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个名为registry-vol的卷</span></span><br><span class="line">docker volume create registry-vol</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下指令，可以看到有一条VOLUME NAME为registry-vol的记录</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>与bind直接使用宿主的文件系统不同，volume由docker直接生成与管理，它跨系统、跨平台、易于备份与迁移。</p><h2 id="二-创建私有仓库"><a href="#二-创建私有仓库" class="headerlink" title="二. 创建私有仓库"></a>二. 创建私有仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从docker hub拉取私有仓库的镜像</span></span><br><span class="line">docker pull registry:2</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># -d 在后台运行容器</span></span><br><span class="line"><span class="comment"># -p 5000:5000 将本地的5000(冒号左边)端口映射到容器的5000(冒号右边)端口</span></span><br><span class="line"><span class="comment"># --mount src=registry-vol,dst=/var/lib/registry 将名为registry-vol的volume映射到容器的/var/lib/registry目录（通过volume的方式进行数据持久化）</span></span><br><span class="line"><span class="comment"># --restart=always 容器自动重启</span></span><br><span class="line"><span class="comment"># -e REGISTRY_STORAGE_DELETE_ENABLED=true 设置环境变量，使得私有仓库中的镜像可以被删除。</span></span><br><span class="line"><span class="comment"># registry:2 image:tag</span></span><br><span class="line">docker run -d -p 5000:5000 --mount <span class="built_in">type</span>=volume,src=registry-vol,dst=/var/lib/registry --restart=always -e REGISTRY_STORAGE_DELETE_ENABLED=<span class="literal">true</span> registry:2</span><br></pre></td></tr></table></figure><p>这里额外提供一个案例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># --mount type=bind,src=/mnt/registry,dst=/var/lib/registry 将本地的/mnt/registry映射到容器的/var/lib/registry目录（通过bind mount的方式进行数据持久化）</span></span><br><span class="line"><span class="comment"># -v `pwd`/config.yml:/etc/docker/registry/config.yml 将本地当前目录的config.yml文件映射到容器的/etc/docker/registry/config.yml。</span></span><br><span class="line">docker run -d -p 5000:5000 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/mnt/registry,dst=/var/lib/registry --restart=always -v `<span class="built_in">pwd</span>`/config.yml:/etc/docker/registry/config.yml registry:2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>第一个案例中的<code>-e REGISTRY_STORAGE_DELETE_ENABLED=true</code>，在第二个案例中可以通过在配置文件中添加<code>registry:storage:delete:enabled:true</code>来替代。</li><li>虽然-v的功能和–mount相似，但推荐使用较为冗长的–mount，因为它简单易懂。</li></ol><p>至此，私有仓库已经创建成功，我们可以通过docker提供的api确认一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问私有仓库的接口</span></span><br><span class="line">curl http://localhost:5000/v2</span><br><span class="line"><span class="comment">#输出结果为&#123;&#125;，说明私有仓库已经在正常运行</span></span><br></pre></td></tr></table></figure><h2 id="三-推送镜像到私有仓库"><a href="#三-推送镜像到私有仓库" class="headerlink" title="三. 推送镜像到私有仓库"></a>三. 推送镜像到私有仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将本地镜像hello:latest（该镜像来自上个笔记）添加一个标签，其中localhost:5000对应私有仓库地址</span></span><br><span class="line">docker tag hello localhost:5000/hello</span><br><span class="line"><span class="comment">#docker根据tag，将镜像提交到私有仓库localhost:5000</span></span><br><span class="line">docker push localhost:5000/hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[&quot;hello&quot;]&#125;，说明已经提交成功。现在即使删除本地的镜像，也可以通过`docker pull localhost:5000/hello`从私有仓库重新获取。</span></span><br></pre></td></tr></table></figure><blockquote><p>repository指的是一组Docker镜像。 repository可以通过推送到仓库服务来分享。同一个repository中的不同镜像可以通过标签来归类。</p></blockquote><p>hello镜像推送成功后，私有仓库会生成一个名为hello的repository。这个repository会存储各个tag的hello镜像，例如：hello:v1、hello:v2。</p><h2 id="四-搭建私有仓库的管理后台"><a href="#四-搭建私有仓库的管理后台" class="headerlink" title="四. 搭建私有仓库的管理后台"></a>四. 搭建私有仓库的管理后台</h2><p>对于私有仓库，docker只提供了http api的接口文档，它并未提供官方的管理后台。为了方便学习，采用第三方提供的<a href="https://github.com/Joxit/docker-registry-ui">Joxit/docker-registry-ui</a>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull joxit/docker-registry-ui:static</span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line"><span class="comment"># -p 5050:80 将本地的5050端口映射到容器的80端口</span></span><br><span class="line"><span class="comment"># -e REGISTRY_URL=http://172.17.0.1:5000 通过环境变量设置容器访问的仓库地址为 http://172.17.0.1:5000</span></span><br><span class="line"><span class="comment"># -e DELETE_IMAGES=true 通过环境变量设置镜像可删除</span></span><br><span class="line"><span class="comment"># -e REGISTRY_TITLE=&quot;My registry&quot; 通过环境变量设置后台的title</span></span><br><span class="line">docker run -d -p 5050:80 -e REGISTRY_URL=http://172.17.0.1:5000 -e DELETE_IMAGES=<span class="literal">true</span> -e REGISTRY_TITLE=<span class="string">&quot;My registry&quot;</span> joxit/docker-registry-ui:static</span><br></pre></td></tr></table></figure><p>这里的REGISTRY_UR并不是 <a href="http://localhost:5000/">http://localhost:5000</a> ，因为容器和本机的localhost并不等价。通过以下方式取得在对应的docker网络中本机的局域网地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后台容器采用默认的bridge网络， 查询该网络的详细属性</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line"><span class="comment">#输出结果中发现IPAM.Config.Gateway为172.17.0.1，这就是本机在bridge网络中的局域网地址了。</span></span><br></pre></td></tr></table></figure><p>通过浏览器访问 <a href="http://localhost:5050/">http://localhost:5050</a> ，可以通过管理后台对私有仓库进行管理了。</p><h2 id="五-删除私有仓库中的hello"><a href="#五-删除私有仓库中的hello" class="headerlink" title="五. 删除私有仓库中的hello"></a>五. 删除私有仓库中的hello</h2><p>通过后台页面，找到删除功能并不复杂。但是即使删除成功，后台的repository列表中依然存在hello（虽然再也无法拉取镜像）。这并不是管理后台的问题，下面通过接口确认：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[&quot;hello&quot;]&#125;，hello的repository依然存在</span></span><br></pre></td></tr></table></figure><p>查阅资料，发现官方指出：</p><ol><li>目前的api只能删除repository中的镜像，而不能删除repository本身。</li><li>私有仓库提供的api只能删除manifests（清单）和layers（层）。所以repository一旦被创建，将无法通过api将其彻底删除。</li><li>api中的删除操作会移除对目标的引用，使得其可以被垃圾回收。同时让它无法被api访问。</li><li>垃圾回收会清理不被任何manifests（清单）引用的数据块，数据块包含layers（层）或manifests（清单）。当manifests（清单）被删除时，它指向的layers（层）中没被其他清单引用的也会被删除。</li></ol><p>也就是说之前通过api删除的，只是repository下的hello:latest镜像，而repository本身依然存在。<br>想要删除repository，需要通过一种stop-the-world（清理期间上传中的镜像可能会被误删）的方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找私有仓库的容器ID</span></span><br><span class="line">docker container ls | grep registry:2</span><br><span class="line"><span class="comment">#容器执行指令</span></span><br><span class="line"><span class="comment"># exec 让容器执行指令</span></span><br><span class="line"><span class="comment"># -it i为交互，t为分配一个冒充的tty</span></span><br><span class="line"><span class="comment"># 74252955fbd9 私有仓库的容器ID，替换为实际ID</span></span><br><span class="line"><span class="comment"># /bin/sh 让容器执行的指令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 74252955fbd9 /bin/sh <span class="comment">#执行后可以直接通过shell操作容器了</span></span><br><span class="line"><span class="comment">#进行垃圾回收</span></span><br><span class="line"><span class="comment"># 垃圾回收会清理不被任何manifests（清单）引用的数据块，数据块包含layers（层）或manifests（清单）</span></span><br><span class="line"><span class="comment"># 当manifests（清单）被删除时，它指向的layers（层）中没被其他清单引用的也会被删除</span></span><br><span class="line">/bin/registry garbage-collect /etc/docker/registry/config.yml</span><br><span class="line"><span class="comment">#删除hello的repository</span></span><br><span class="line">rm -rf /var/lib/registry/docker/registry/v2/repositories/hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过docker的http api查看存储的repository列表</span></span><br><span class="line">curl http://localhost:5000/v2/_catalog</span><br><span class="line"><span class="comment">#输出结果为：&#123;&quot;repositories&quot;:[]&#125;，说明已经hello已经被彻底删除</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Dockerfile生成镜像</title>
      <link href="/2019/04/29/docker-build-image/"/>
      <url>/2019/04/29/docker-build-image/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/get-started/part2/">Get Started, Part 2: Containers</a><br><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></p></blockquote><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>这里将通过一个简单的场景来学习Dockerfile的使用：制作一个安装了openresty的centos的镜像（image）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> Kubernetes:</span><br><span class="line">  Version:          v1.10.11</span><br><span class="line">  StackAPI:         v1beta2</span><br></pre></td></tr></table></figure><h2 id="一-创建一个工作目录"><a href="#一-创建一个工作目录" class="headerlink" title="一. 创建一个工作目录"></a>一. 创建一个工作目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后续这个目录将存放Dockerfile和entrypoint.sh</span></span><br><span class="line">mkdir hello</span><br></pre></td></tr></table></figure><h2 id="二-在工作目录中创建一个Dockerfile文件"><a href="#二-在工作目录中创建一个Dockerfile文件" class="headerlink" title="二. 在工作目录中创建一个Dockerfile文件"></a>二. 在工作目录中创建一个Dockerfile文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像，并且必须是第一条指令（如果不需要基础镜像，那么替换为 FROM scratch）</span></span><br><span class="line"><span class="comment"># 这里的centos是镜像名，7是标签。这里对应系统centos 7</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器的工作路径，对后续的RUN, CMD, ENTRYPOINT, COPY, ADD生效（如果对应的目录不存在则会创建，可以重复设置）</span></span><br><span class="line"><span class="comment"># 这里会在容器中创建一个/app文件夹，下面的对应操作会在/app中进行</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地拷贝文件到容器</span></span><br><span class="line"><span class="comment"># 这里会把本地的demo目录内的全部文件拷贝到容器的/app目录下（./指当前目录，而当前目录通过WORKDIR定义）</span></span><br><span class="line">COPY * ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器在build时执行指令</span></span><br><span class="line">RUN yum install -y lsof git</span><br><span class="line">RUN yum install -y yum-utils</span><br><span class="line">RUN yum-config-manager -y --add-repo https://openresty.org/package/centos/openresty.repo</span><br><span class="line">RUN yum install -y openresty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动时执行指令，CMD命令的功能类似，但主要区别在于CMD可被dock run的COMMAND参数覆盖，而ENTRYPOINT不会</span></span><br><span class="line"><span class="comment"># 如果CMD或ENTRYPOINT配置了多条，且CMD指令不是完整的可执行命令，那么CMD的内容将成为ENTRYPOINT的参数。反之仅最后一条生效。</span></span><br><span class="line"><span class="comment"># 当容器启动时会执行/app/entrypoint.sh文件（build的时候不会执行），该文件在上面的COPY操作中被docker从本地的工作目录拷贝到了容器的/app目录</span></span><br><span class="line">ENTRYPOINT ./entrypoint.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外开放端口</span></span><br><span class="line"><span class="comment"># 若果不将80端口对外暴露，容器外将无法访问容器的80端口</span></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><h2 id="三-在工作目录中创建一个entrypoint-sh文件"><a href="#三-在工作目录中创建一个entrypoint-sh文件" class="headerlink" title="三. 在工作目录中创建一个entrypoint.sh文件"></a>三. 在工作目录中创建一个entrypoint.sh文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动openresty服务</span></span><br><span class="line">openresty</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker会将没有前台守护进程的容器直接关闭，所以这里通过本指令阻塞脚本的执行</span></span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure><p>文件生成完成后，记得还要通过<code>chmod +x entrypoint.sh</code>给脚本加上执行权限，否则容器启动时将无法执行脚本。</p><h2 id="四-在工作目录下build镜像"><a href="#四-在工作目录下build镜像" class="headerlink" title="四. 在工作目录下build镜像"></a>四. 在工作目录下build镜像</h2><blockquote><p>Usage:    docker build [OPTIONS] PATH | URL | -</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待生成镜像的name为hello，tag为缺省值latest，路径为.（当前工作目录）</span></span><br><span class="line">docker build -t hello .</span><br><span class="line"><span class="comment"># 指令执行完成后，控制台输出镜像完整的ID</span></span><br></pre></td></tr></table></figure><p>执行<code>docker image ls</code>，docker会打印出本地存储的全部镜像，其中REPOSITORY为hello，TAG为latest的记录对应刚创建的镜像。</p><h2 id="五-创建容器"><a href="#五-创建容器" class="headerlink" title="五. 创建容器"></a>五. 创建容器</h2><blockquote><p>Usage:    docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 该容器在后台执行</span></span><br><span class="line"><span class="comment"># -p 4000:80 将容器的80端口映射到本地的4000端口（通过localhost:4000访问容器的openresty的80端口）。</span></span><br><span class="line"><span class="comment"># hello 使用镜像hello</span></span><br><span class="line">docker run -d -p 4000:80 hello</span><br><span class="line"><span class="comment"># 指令执行完成后，控制台输出容器完整的ID</span></span><br></pre></td></tr></table></figure><p>执行<code>docker container ls</code>，docker会打印出本地执行中的全部容器，其中IMAGE为hello的记录对应刚启动的容器。<br>打开浏览器访问<code>http://localhost:4000</code>，可以看到openrestry的默认主页，至此镜像及其对应的容器已创建完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft算法分析</title>
      <link href="/2019/04/22/raft/"/>
      <url>/2019/04/22/raft/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>Raft算法用于保证分布式系统的强一致性，被目前知名的etcd所采用。</p><h2 id="一-心跳"><a href="#一-心跳" class="headerlink" title="一. 心跳"></a>一. 心跳</h2><p>集群中每个节点都需要定期向其他节点发送心跳包，如果超过一半的节点超过一定时间(阈值)未收到该节点的心跳包，那么认定该节点已下线。</p><img  src=http://www.plantuml.com/plantuml/svg/Uz7LzBnffwE2ZQwTmWimsybAuUd-vXVRDtFbvPUaAXHbfcUK08Ncxtgogo-ZfAJWvTJzB_RFUzQtzFcibkAIejJ4tESRTp-Tr_soOTRBnibSBp0CT8ORY2ddWaVE5KtE2O-PJdZCTC9ZfZCUVSJAePlfWaqE0000><h2 id="二-选举"><a href="#二-选举" class="headerlink" title="二. 选举"></a>二. 选举</h2><p>集群中节点角色可为Leader、Follower或Candidate其中一个。当Follower在一定时间内没有收到来自Leader的心跳，会将自己角色变更为Candidate，然后等待一段随机的时间后，发起选举。</p><img  src=http://www.plantuml.com/plantuml/svg/dLPDKzfG55sJNy6uqd5STEl26MljgZ_13JDagZCCT2ZJkkIZV8DW5R0OeBNWM9GlYn2Co8zfxajOzI_qlhmG0m6jBc0Wxxvpppltt7Upw_RuUBld4--rgucW4XnisjVjxtY7a_Skov94XCgwUuNRdOrwZL5lFIwNvpFlvHmkdvsKQcgqpZOgnIym2gdztv0AgxqmAVGusmHyRMFV1649cvjeo-5sxZaTFfwpkJoU3vpDDbbRsp25AOqut8V7nGmHRX5iNEXYf8RdtNk_wyE8SM04uJHKYx9ODq0Xcy9eo1ogD_snFowBzuiIi1ZbienXV-zIkZohg-xPFAIL8LS_p90OFWuDvRkYslp5zgs-mbsQSiSzYBLH07KKXNI2vDge7qkwZCgGv1KA2_tEYdfJ9h4iHT8WyJSaAWXY9Rjba6MXQgjFEa4QEYs7QL4M9VKyWFaWUqc4AwJFLf4BuokB1xAOGE6842Uv67k8gqJmatoR56emAj2_twEGwJ-mshAlJMcejceMu3GvQJ4OF1n9VbMaaeKhX7kob6Su85mWHLq5eQv8HwIaKGc58N8ZYqbsTlasWf3ut2Y1FAX0kqEpnVrg-mYNbbWr8NAjr0DBSyLyir3CoVh-z17Xj0pLzCJHSn2tdq3Sdj4C_DzeuAW4ZHDwp5oRf9ie6pHJ9DTzH3Dj7yD1wq7sqAmYoMJb-rFcBOgQRpzUw1ttJAcLkpoM6jERKMMfHXfLY5L9lc7ER_16zI5xpgZ_yMkdVghfRRph8s_7Ih-qLQ3QKRkrPxRA0lzgo2yqodz3FTSX-Z4r5rEV3oFG6f3yW1MFd7PfTSLZLW73DWy4fcoZfo2DdzXe35aM6mnMJsbkC5dqgyEcqMPOqnqtd0T9MT23ZKutsXoVK3Znc7aQSHWdmoIK76E1lYM976Egr2uUSunbQaqfk-3sOxSepOTpA7ghpnVDSBhqewXoaKG1cFaMpJb4KAGOQPmP8sJ-37aSPU7PZ5bhwV5CImqDgR8Q91nKhAZBnbFZneNCoOf-8Ku0p5rireP9phkTdFP5Fzh4Dq0dZNy0pHoENYfLu0nlGFFGdpVpEMtyMTDIBsYsD0GqzjEN4tO6w5-pUv-RezZcb69QCQrfaEV2DudfIbfYA3vj3r7adgoNhja_><h2 id="三-强一致"><a href="#三-强一致" class="headerlink" title="三. 强一致"></a>三. 强一致</h2><p>假设集群中最多n台机器发生故障，那么最少需要2n+1个节点。比起在拜占庭问题中最少需要3n+1个节点，raft协议的优势在于节点不存在欺骗问题。</p><img  src=http://www.plantuml.com/plantuml/svg/bPBFIiD04CRlFaNeIG--W0V1YwVUlNWH35Ke3PI2rneKGqX8n9fAJKaBJV6GHW-IDar2NcPdDZTVmPMDQFD7wctPcT_CDzyC7RoWiXJs3uN6iTHkIrTYDrDbAeUx9FBs6iA1WC_lQBtXWquIUwSwYT5DyUpy-vT1MUA1SPz36x5oxibH4uSkfCDIOfqaC3LSk3dKaNgYqBriNVHOX4vzaewpu3PBxyYg3xfAHpUS_WsXOeBgr4rJbbZ1RhIjB4JY4IWpj1QSPefmx38vl0nxa2X2sy6dLp3dNr7R-OYrqmw40LaDS1AYxgFjeJT5moJhsGyQMs0iyzfpcIIFMPg0EgbniJ0BtoTL0-nVextUslGYjxLv1J3txtzj-IM1hp7wZywKNtCLzGa0>]]></content>
      
      
      
        <tags>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>voltdb的部署</title>
      <link href="/2018/09/29/voltdb-deploy/"/>
      <url>/2018/09/29/voltdb-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>Voltdb作为分布式的内存数据库，企业版比社区版主要多提供了命令日志(事务级别的持久化日志)、不停机的弹性扩容、用于灾难恢复的数据库备份、跨数据中心的备份。</p><h2 id="一-下载安装"><a href="#一-下载安装" class="headerlink" title="一. 下载安装"></a>一. 下载安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.voltdb.com/technologies/server/voltdb-latest.tar.gz</span><br><span class="line">tar -zxvf voltdb-latest.tar.gz</span><br><span class="line">mv voltdb-community-7.8.2 /usr/<span class="built_in">local</span>/voltdb</span><br><span class="line">mkdir /data/voltdb <span class="comment">#这个目录存放voltdb的数据</span></span><br></pre></td></tr></table></figure><h2 id="二-系统配置"><a href="#二-系统配置" class="headerlink" title="二. 系统配置"></a>二. 系统配置</h2><ol><li>voltdb不支持大页内存，终端执行以下指令，同时将它们写入<code>/etc/rc.local</code>文件：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure></li><li>将voltdb的可执行文件加入PATH：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新Path</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;PATH=/usr/local/voltdb/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="comment">#终端执行以下指令立刻执行变更：</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-初始化和运行"><a href="#三-初始化和运行" class="headerlink" title="三. 初始化和运行"></a>三. 初始化和运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">voltdb init --dir /data/voltdb/ <span class="comment">#如果以前启动过，需要强制初始化，加上 --force</span></span><br><span class="line">voltdb start --dir /data/voltdb/</span><br></pre></td></tr></table></figure><h2 id="四-测试数据插入"><a href="#四-测试数据插入" class="headerlink" title="四. 测试数据插入"></a>四. 测试数据插入</h2><p>1 . 终端执行<code>sqlcmd</code>进入sql终端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table <span class="built_in">test</span>(id int); <span class="comment">#创建测试表</span></span><br><span class="line">create procedure ping as insert into <span class="built_in">test</span>(id) values(?); <span class="comment">#创建存储过程</span></span><br></pre></td></tr></table></figure><p>2 . 在终端通过http执行存储过程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -d <span class="string">&quot;Procedure=ping&amp;Parameters=%5B0%5D&quot;</span> <span class="string">&quot;http://localhost:8080/api/1.0/&quot;</span></span><br><span class="line"><span class="comment">#其中%5B0%5D未转码前是`[0]`，所以这里等同于 `call ping (0)`</span></span><br></pre></td></tr></table></figure><h2 id="五-常用指令"><a href="#五-常用指令" class="headerlink" title="五. 常用指令"></a>五. 常用指令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">voltadmin save <span class="comment">#立刻生成快照</span></span><br><span class="line">voltadmin shutdown <span class="comment">#停止集群(不要直接停止voltdb进程，应该使用voltadmin)</span></span><br><span class="line">voltadmin shutdown —save <span class="comment">#停止集群并生成快照</span></span><br><span class="line">voltadmin pause <span class="comment">#停止客户端服务，进入维护模式</span></span><br><span class="line">voltadmin resume <span class="comment">#退出维护模式</span></span><br><span class="line">voltdb start --pause</span><br><span class="line">voltadmin save --blocking &#123;path&#125; &#123;file-prefix&#125; <span class="comment">#在path目录下生成file-prefix为前缀的备份文件</span></span><br><span class="line">voltadmin restore &#123;path&#125; &#123;file-prefix&#125;</span><br></pre></td></tr></table></figure><h2 id="六-使用须知"><a href="#六-使用须知" class="headerlink" title="六. 使用须知"></a>六. 使用须知</h2><ol><li>所有节点的内存大小与核数应保持一致。</li><li>每个节点的默认分区数为8，推荐分区数为：cpu核数 × 0.75 (非超线程处理器)。</li><li>每个分区有且只有一个线程读写，不存在锁冲突。分区越多并发越高，自然性能也越高。</li><li>一个表只有一个分区列，每个表通过hash分区列，把每行数据分布到不同的分区。</li><li>合理的分区列直接决定该表的增删改查性能。</li><li>如果分区表存在主键，那么主键中必须包含分区列。</li><li>分区列不能为空，且必须为<code>TINYINT</code>、<code>SMALLINT</code>、 <code>INTEGER</code>、<code>BIGINT</code>、<code>VARCHAR</code>类型。</li><li>没有分区列的表是复制表，全部分区都会保存一份。所以虽然插入与存储成本高，但是查询成本低，适合更新较少但查询较多的小表。</li><li>存在数据的列无法添加唯一、假定唯一、主键约束。</li><li>被存储过程引用的表无法直接删除，需先删除对应存储过程。被索引和视图引用的表也无法直接删除，但是可以用<code>DROP TABLE 表名 IF EXISTS CASCADE</code>来级联删除。</li><li>K-Safe的值代表可以保证数据不丢失的最小可以同时发生故障的服务器数。假设为K-Safe值为<code>n</code>，节点数为<code>a</code>，每个节点分区数为<code>b</code>，那么一条数据有<code>n+1</code>个拷贝，每<code>a×b/(n+1)</code>个分区存有一份完整的数据。</li><li>集群间每台服务器需开启NTP保证节点间时间差异不超过200ms。</li><li>存储过程返回结果不能超过50MB。 </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> voltdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH自动断开的解决方法</title>
      <link href="/2018/09/29/ssh-disconnect/"/>
      <url>/2018/09/29/ssh-disconnect/</url>
      
        <content type="html"><![CDATA[<p>在服务端(centos)执行以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ClientAliveInterval 60&quot;</span> &gt;&gt; /etc/ssh/sshd_config  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ClientAliveCountMax 1&quot;</span> &gt;&gt; /etc/ssh/sshd_config  </span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven打包时在META-INF/MANIFEST.MF中添加主清单属性</title>
      <link href="/2018/05/26/maven-manifest/"/>
      <url>/2018/05/26/maven-manifest/</url>
      
        <content type="html"><![CDATA[<h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题:"></a>发现问题:</h2><p>默认使用<code>mvn clean package</code>生成的jar文件中的 <strong>MANIFEST.MF</strong> 是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: Apache Maven 3.3.9</span><br><span class="line">Built-By: shengyayun</span><br><span class="line">Build-Jdk: 10.0.1</span><br></pre></td></tr></table></figure><p>这种jar文件执行的时候会返回 <strong>xxx.jar中没有主清单属性</strong>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p>修改 <strong>pom.xml</strong>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>com.shengyayun.App<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span> #划重点</span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在重新打包生成的MANIFEST.MF中多了一行<code>Main-Class: com.shengyayun.App</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
            <tag> manifest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx站点访问日志</title>
      <link href="/2018/04/26/nginx-log-format/"/>
      <url>/2018/04/26/nginx-log-format/</url>
      
        <content type="html"><![CDATA[<h2 id="一-在nginx-conf的http块中添加日志格式main2018："><a href="#一-在nginx-conf的http块中添加日志格式main2018：" class="headerlink" title="一. 在nginx.conf的http块中添加日志格式main2018："></a>一. 在nginx.conf的<code>http</code>块中添加日志格式<code>main2018</code>：</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main2018 <span class="string">&#x27;$remote_addr|$remote_user|$time_local|$request|$status|$body_bytes_sent|$http_referer|$http_user_agent|$http_x_forwarded_for|$request_time|$upstream_response_time|$upstream_addr|$upstream_status&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="二-在对应项目的server中配置该站点的访问日志："><a href="#二-在对应项目的server中配置该站点的访问日志：" class="headerlink" title="二. 在对应项目的server中配置该站点的访问日志："></a>二. 在对应项目的<code>server</code>中配置该站点的访问日志：</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">access_log</span> /var/log/www.access main2018; <span class="comment">#使用第一步中添加的格式main2018</span></span><br></pre></td></tr></table></figure><h2 id="三-重启nginx"><a href="#三-重启nginx" class="headerlink" title="三. 重启nginx"></a>三. 重启nginx</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t <span class="comment">#判断配置正确</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="四-查看访问日志"><a href="#四-查看访问日志" class="headerlink" title="四. 查看访问日志"></a>四. 查看访问日志</h2><p>在服务器上执行如下指令查看最近一次访问的记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 1 /var/<span class="built_in">log</span>/www.access | awk -F <span class="string">&quot;|&quot;</span> <span class="string">&#x27;&#123;printf &quot;客户端地址: %s\n访问时间和时区: %s\n客户端用户名称: %s\n请求的URI和HTTP协议: %s\nHTTP请求状态: %s\n发送给客户端文件内容大小: %s\nurl跳转来源: %s\n客户端信息: %s\nHTTP的请求端真实的IP: %s\n请求的总时间: %s\nupstream响应时间: %s\nupstream地址: %s\nupstream状态: %s\n\n&quot;,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13&#125;</span></span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">客户端地址: 115.238.29.221</span><br><span class="line">访问时间和时区: -</span><br><span class="line">客户端用户名称: 26/Apr/2018:17:29:20 +0800</span><br><span class="line">请求的URI和HTTP协议: POST /api HTTP/1.1</span><br><span class="line">HTTP请求状态: 200</span><br><span class="line">发送给客户端文件内容大小: 260</span><br><span class="line">url跳转来源: -</span><br><span class="line">客户端信息: okhttp/3.8.1</span><br><span class="line">HTTP的请求端真实的IP: 115.238.29.223</span><br><span class="line">请求的总时间: 0.017</span><br><span class="line">upstream响应时间: 0.017</span><br><span class="line">upstream地址: 127.0.0.1:9000</span><br><span class="line">upstream状态: 200</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb的Replica Sets</title>
      <link href="/2017/12/10/mongodb-replica-sets/"/>
      <url>/2017/12/10/mongodb-replica-sets/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><ol><li>我使用了3台服务器来部署Replica Sets，分别为主节点ma、从节点mb、仲裁节点mc(这里的ma、mb、mc已经被我配置进了hosts，可以直接被解析为ip)。</li><li>其中主节点负责写与实时读，从节点负责非实时读（主从数据同步存在延迟）。</li><li>仲裁节点不提供数据读写支持，但会在主节点停止工作后将从节点升级为主节点。</li></ol><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h2><p>新建文件**/etc/yum.repos.d/mongodb-enterprise.repo**，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mongodb-enterprise]</span></span><br><span class="line"><span class="attr">name</span>=MongoDB Enterprise Repository</span><br><span class="line"><span class="attr">baseurl</span>=https://repo.mongodb.com/yum/redhat/<span class="variable">$releasever</span>/mongodb-enterprise/<span class="number">3.4</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://www.mongodb.org/static/pgp/server-<span class="number">3.4</span>.asc</span><br></pre></td></tr></table></figure><p>然后直接通过yum安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mongodb-enterprise</span><br></pre></td></tr></table></figure><h2 id="二-编辑配置文件"><a href="#二-编辑配置文件" class="headerlink" title="二. 编辑配置文件"></a>二. 编辑配置文件</h2><p>执行<code>vi /etc/mongod.conf</code>，配置内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#monogodb</span><br><span class="line"></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file #日志输出目的地</span><br><span class="line">  logAppend: true #当mongod/mongos重启后，是否在现有日志的尾部继续添加日志</span><br><span class="line">  path: /var/log/mongodb/mongod.log #日志路径</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /var/lib/mongo #mongod进程存储数据目录</span><br><span class="line">  indexBuildRetry: true #当构建索引时mongod意外关闭，那么再次启动重新构建索引</span><br><span class="line">  directoryPerDB: true #不同DB的数据存储在不同的目录中</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true #开启journal日志持久存储，journal日志用来数据恢复</span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true #主进程fork出一个子进程在后台执行</span><br><span class="line">  pidFilePath: /var/run/mongodb/mongod.pid #pid文件地址</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27017  #默认端口</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  authorization: enabled #是否开启用户访问控制</span><br><span class="line">  clusterAuthMode: keyFile #集群中members之间的认证模式</span><br><span class="line">  keyFile: /etc/mongodb-keyfile #keyfile的位置</span><br><span class="line">  javascriptEnabled: false #是否关闭server端的javascript功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs0 #复制集的名称</span><br><span class="line">  oplogSizeMB: 8192 #replication操作日志的最大尺寸，单位：MB</span><br></pre></td></tr></table></figure><h2 id="三-在全部节点上都需要进行步骤一和步骤二，全部完成后再进行以下操作"><a href="#三-在全部节点上都需要进行步骤一和步骤二，全部完成后再进行以下操作" class="headerlink" title="三. 在全部节点上都需要进行步骤一和步骤二，全部完成后再进行以下操作"></a>三. 在全部节点上都需要进行步骤一和步骤二，全部完成后再进行以下操作</h2><h2 id="四-配置集群间认证文件mongodb-keyfile"><a href="#四-配置集群间认证文件mongodb-keyfile" class="headerlink" title="四. 配置集群间认证文件mongodb-keyfile"></a>四. 配置集群间认证文件mongodb-keyfile</h2><p>1 . 在主节点ma上执行<code>openssl rand -base64 745 &gt; /etc/mongodb-keyfile</code>。</p><p>2 . 将生成的**/etc/mongodb-keyfile**文件复制到其他节点的相同路径。</p><p>3 . 所有的节点上修改该文件的拥有者与权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /etc/mongodb-keyfile</span><br><span class="line">chown mongod:mongod /etc/mongodb-keyfile</span><br></pre></td></tr></table></figure><h2 id="五-在主节点进行集群初始化和管理员账号设置"><a href="#五-在主节点进行集群初始化和管理员账号设置" class="headerlink" title="五. 在主节点进行集群初始化和管理员账号设置"></a>五. 在主节点进行集群初始化和管理员账号设置</h2><p>1 . 编辑主节点的配置文件**/etc/mongod.conf**，将<code>security</code>下的<code>authorization</code>编辑为<code>disabled</code>。</p><blockquote><p>authorization为enable时无法创建管理员账号。</p></blockquote><p>2 . 主节点执行以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mongod.service</span><br><span class="line">systemctl <span class="built_in">enable</span> mongod.service</span><br></pre></td></tr></table></figure><p>3 . 执行<code>mongo</code>进入mongo shell，然后执行以下指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate()</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>: <span class="string">&quot;root&quot;</span>,<span class="attr">pwd</span>: <span class="string">&quot;非常复杂的超级管理员密码&quot;</span>,<span class="attr">roles</span>: [ &#123; <span class="attr">role</span>: <span class="string">&quot;root&quot;</span>, <span class="attr">db</span>: <span class="string">&quot;admin&quot;</span> &#125; ]&#125;);</span><br></pre></td></tr></table></figure><p>4 . 退出mongo shell，编辑**/etc/mongod.conf**，将<code>security</code>下的<code>authorization</code>改回为<code>enabled</code>。<br>5 . 执行 <code>systemctl restart mongod.service</code>来重启mongodb服务。</p><h2 id="六-启动其他节点的mongodb服务"><a href="#六-启动其他节点的mongodb服务" class="headerlink" title="六. 启动其他节点的mongodb服务"></a>六. 启动其他节点的mongodb服务</h2><p>在其他节点上启动mongodb服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mongod.service</span><br><span class="line">systemctl <span class="built_in">enable</span> mongod.service</span><br></pre></td></tr></table></figure><h2 id="七-把其他节点添加到集群"><a href="#七-把其他节点添加到集群" class="headerlink" title="七. 把其他节点添加到集群"></a>七. 把其他节点添加到集群</h2><blockquote><p>第五步中已经在主节点里对集群进行了初始化，然后第六步中启动了从节点和仲裁节点的mongodb服务，现在就差将它们加入集群了。</p></blockquote><p>1 . 在主节点执行<code>mongo</code>进入mongo shell，执行以下指令完成用户认证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;非常复杂的超级管理员密码&#x27;</span>)</span><br></pre></td></tr></table></figure><p>2 . 添加从节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(<span class="string">&#x27;mb:27017&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3 . 添加仲裁节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.addArb(<span class="string">&#x27;mc:27017&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="八-创建业务用的数据库与账号"><a href="#八-创建业务用的数据库与账号" class="headerlink" title="八. 创建业务用的数据库与账号"></a>八. 创建业务用的数据库与账号</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use test_db</span><br><span class="line">db.createUser(&#123;<span class="attr">user</span>:<span class="string">&#x27;test_user&#x27;</span>,<span class="attr">pwd</span>:<span class="string">&#x27;复杂的test_user的密码&#x27;</span>,<span class="attr">roles</span>:[&#123;<span class="attr">role</span>:<span class="string">&quot;readWrite&quot;</span>,<span class="attr">db</span>:<span class="string">&quot;test_db&quot;</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure><p>现在，业务里可以通过连接字符串<code>mongodb://test_user:复杂的test_user的密码@ma:27017,mb:27017/test_db</code>来对该集群进行读写了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swoole_http_server中request的全局对象</title>
      <link href="/2017/11/12/swoole-http-server-request-global/"/>
      <url>/2017/11/12/swoole-http-server-request-global/</url>
      
        <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * http.php</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      shengyayun&lt;719048774<span class="doctag">@qq</span>.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>       2017/11/12 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">$http</span> = <span class="keyword">new</span> swoole_http_server(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9501</span>);</span><br><span class="line"><span class="variable">$http</span>-&gt;set(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&#x27;worker_num&#x27;</span> =&gt; <span class="number">2</span>,<span class="comment">//开启2个worker进程</span></span><br><span class="line">        <span class="string">&#x27;dispatch_mode&#x27;</span> =&gt; <span class="number">1</span>,<span class="comment">//request轮询分配给每个worker进程</span></span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"><span class="variable">$http</span>-&gt;on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$request</span>, <span class="variable">$response</span></span>) </span>&#123;</span><br><span class="line">    App::init(<span class="variable">$request</span>, <span class="variable">$response</span>);<span class="comment">//必须放在最前面，不然下一个request可能取到上一个request的gpc</span></span><br><span class="line">    <span class="variable">$result</span> = (<span class="keyword">new</span> A())-&gt;run();<span class="comment">//调用实现类</span></span><br><span class="line">    <span class="variable">$response</span>-&gt;end(<span class="string">&quot;子进程(&quot;</span> . getmypid() . <span class="string">&quot;)完成请求的处理：&quot;</span> . <span class="variable">$result</span>);<span class="comment">//request请求是在worker进程执行的</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$http</span>-&gt;start();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;主进程(&quot;</span> . getmypid() . <span class="string">&quot;)已启动&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放全局对象，进程内唯一，进程内全局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array 进程内的全局对象GPC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$GPC</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="variable">$request</span>, <span class="variable">$response</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> ([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;cookie&#x27;</span>, <span class="string">&#x27;files&#x27;</span>] <span class="keyword">as</span> <span class="variable">$attr</span>) &#123;</span><br><span class="line">            <span class="built_in">self</span>::<span class="variable">$GPC</span>[<span class="variable">$attr</span>] = property_exists(<span class="variable">$request</span>, <span class="variable">$attr</span>) ? <span class="variable">$request</span>-&gt;<span class="variable">$attr</span> : [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$response</span>-&gt;header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在具体业务实现中取得全局对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取全局gpc对象</span></span><br><span class="line">        <span class="keyword">return</span> var_export(App::<span class="variable">$GPC</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用php实现curl的data-binary</title>
      <link href="/2017/10/01/php-curl-data-binary/"/>
      <url>/2017/10/01/php-curl-data-binary/</url>
      
        <content type="html"><![CDATA[<p>如果我想往influxdb中插入一条数据，教程告诉我可以这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST <span class="string">&#x27;http://127.0.0.1:8086/write?db=metrics&#x27;</span> -u admin:admin --data-binary <span class="string">&#x27;test,host=localhost count=1&#x27;</span></span><br></pre></td></tr></table></figure><p>但是现在我需要用php来实现。经过查阅网上资料，有人说可以先将<code>test,host=localhost count=1</code>转为stream，然后php进行curl的时候设置<code>CURLOPT_INFILE</code>、<code>CURLOPT_INFILESIZE</code>、<code>CURLOPT_UPLOAD</code>。这样操作下来虽然influxb虽然返回了204，但是数据并没有正确插入。</p><p>最后我使用了以下的代码实现了功能：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ch</span> = curl_init();<span class="comment">//init</span></span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_TIMEOUT, <span class="number">1</span>); <span class="comment">//一秒超时</span></span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="string">&quot;http://127.0.0.1:8086/write?db=metrics&quot;</span>);</span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_BINARYTRANSFER, <span class="literal">TRUE</span>);<span class="comment">//二进制传输</span></span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_USERPWD, <span class="string">&#x27;123&#x27;</span>);<span class="comment">//权限认证</span></span><br><span class="line">curl_setopt(<span class="variable">$ch</span>, CURLOPT_POSTFIELDS, <span class="string">&#x27;test,host=localhost count=1&#x27;</span>);<span class="comment">//写操作只能用post</span></span><br><span class="line">curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">curl_close(<span class="variable">$ch</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> influxdb </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grafana的部署</title>
      <link href="/2017/09/30/grafana-deploy/"/>
      <url>/2017/09/30/grafana-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>grafana 是基于JS开发的，功能齐全的度量仪表盘和图形编辑器。我们可以通过collectd和业务代码采集数据，通过influxdb存储数据，最后通过grafana的web端进行展现。</p><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.5.2-1.x86_64.rpm</span><br><span class="line">sudo yum localinstall grafana-4.5.2-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="二-http配置修改"><a href="#二-http配置修改" class="headerlink" title="二. http配置修改"></a>二. http配置修改</h2><p>用vim打开文件/etc/grafana/grafana.ini，下面我们查看<code>[server]</code>的配置：</p><ul><li><code>http_port</code>默认是<code>3000</code>，代表它自带的http服务默认监听3000端口。</li><li><code>domain</code>默认是<code>localhost</code>，结合上面的默认端口，我们可以通过<code>http://localhost:3000</code>来访问grafana的图形化界面。</li><li><code>root_url</code>这个配置主要为了在使用反向代理后能正常跳转，同时邮件可以提供正确的url。</li></ul><p>这里有个案例，我希望可以通过<code>http://watch.langdaren.com</code>直接访问grafana，但80端口已经被nginx占用：</p><ol><li><code>http_port</code>不修改，保留默认的<code>3000</code>。</li><li><code>domain</code>改为<code>watch.langdaren.com</code>。</li><li><code>root_url</code>改为<code>http://watch.langdaren.com</code>。</li><li>修改nginx配置，添加一条这样的server配置：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">　　<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">　　<span class="attribute">server_name</span>  watch.langdaren.com;</span><br><span class="line">　　<span class="attribute">location</span> / &#123;</span><br><span class="line">　　　　<span class="attribute">proxy_pass</span>   http://127.0.0.1:3000;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>nginx配置修改完记得先执行<code>nginx -t</code>测试一下配置，然后再执行<code>nginx -s reload</code>进行重启。</li></ol><h2 id="三-smtp配置修改"><a href="#三-smtp配置修改" class="headerlink" title="三. smtp配置修改"></a>三. smtp配置修改</h2><p>配置正确的smtp，可以让grafana可以自动发送邮件，下面我使用我的腾讯邮箱进行配置。<br>用vim打开配置文件，下面我们查看<code>[smtp]</code>的配置：</p><ol><li><code>enabled</code>修改为<code>true</code>。</li><li><code>host</code>修改为邮件系统的发送服务器地址，这里是<code>smtp.exmail.qq.com:465</code>。</li><li><code>user</code>修改为我的邮箱全名<code>719048774@qq.com</code>。</li><li><code>password</code>修改为我的邮箱密码。</li><li><code>from_address</code>修改为邮箱全名<code>719048774@qq.com</code>。</li><li><code>from_name</code>改为<code>shengyayun</code>。</li></ol><h2 id="四-管理员账号配置修改"><a href="#四-管理员账号配置修改" class="headerlink" title="四. 管理员账号配置修改"></a>四. 管理员账号配置修改</h2><p>用vim打开配置文件，下面我们查看<code>[security]</code>的配置：</p><ol><li><code>admin_user</code>默认为<code>admin</code>，这个是管理员账号名，按需修改。</li><li><code>admin_password</code>默认为<code>admin</code>，这个是管理员密码，按需修改。</li></ol><h2 id="五-服务运行与开机自启动"><a href="#五-服务运行与开机自启动" class="headerlink" title="五. 服务运行与开机自启动"></a>五. 服务运行与开机自启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start grafana-server</span><br><span class="line">systemctl <span class="built_in">enable</span> grafana-server</span><br></pre></td></tr></table></figure><h2 id="六-测试"><a href="#六-测试" class="headerlink" title="六. 测试"></a>六. 测试</h2><p>通过第二步的http配置，就知道如何访问grafana的web端了。默认的地址是<code>http://localhost:3000</code>，在我的案例里的地址是<code>http://watch.langdaren.com</code>。</p><h2 id="七-其他"><a href="#七-其他" class="headerlink" title="七. 其他"></a>七. 其他</h2><p>grafana访问influxdb并创建dashboard之类操作，都是通过grafana的web端的管理员功能完成的，这里不做详细介绍，具体可以查看官网<code>http://docs.grafana.org</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>collectd的部署</title>
      <link href="/2017/09/30/collectd-deploy/"/>
      <url>/2017/09/30/collectd-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>collectd是一款性能监控程序，这里我将采用它对服务器进行监控，然后将数据写入influxdb。阅读该文档前先阅读influxdb的相关文档。</p><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install collectd</span><br><span class="line">yum install collectd-rrdtool</span><br></pre></td></tr></table></figure><h2 id="二-修改配置"><a href="#二-修改配置" class="headerlink" title="二. 修改配置"></a>二. 修改配置</h2><ol><li>用vim打开/etc/collectd.conf文件。</li><li>将<code>QDNLookup</code>修改为<code>false</code>。如果要保留为默认的<code>true</code>的话，host必须与ip保持一致。</li><li>取消<code>LoadPlugin logfile</code>的注释，同时取消<code>&lt;Plugin logfile&gt;...&lt;/Plugin&gt;</code>的注释，将其中<code>File Stdout</code>一行改为<code>File &quot;/var/log/collectd.log&quot;</code>，这样collectd的日志会被单独写进这个文件里。</li><li>取消rrdtool组件的注释：<br><code>LoadPlugin rrdtool</code></li><li>为了后续测试collectd功能，取消cpu组件的注释：<br><code>LoadPlugin cpu</code></li><li>通过配置network组件将监控数据传给influxdb：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Plugin</span> <span class="attr">network</span>&gt;</span></span><br><span class="line">　　Server &quot;127.0.0.1&quot; &quot;25826&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">Plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>这里的<code>127.0.0.1</code>是influxdb的ip地址，<code>25826</code>是influxdb监听的端口号。</li></ol><h2 id="三-配置influxdb的collectd插件"><a href="#三-配置influxdb的collectd插件" class="headerlink" title="三. 配置influxdb的collectd插件"></a>三. 配置influxdb的collectd插件</h2><ol><li>用vim打开/etc/influxdb/influxdb.conf文件</li><li>将<code>[[collectd]]</code>下面的<code>enabled</code>取消注释，并改为<code>true</code>。</li><li>将<code>[[collectd]]</code>下面的<code>typesdb</code>取消注释，改为/etc/collectd.conf文件中<code>TypesDB</code>指向的<code>types.db</code>文件所在的<strong>目录</strong>。</li><li>重启influxdb服务。</li><li>通过influx shell创建一个新的数据库，取名collectd。</li></ol><h2 id="四-前台执行"><a href="#四-前台执行" class="headerlink" title="四. 前台执行"></a>四. 前台执行</h2><p>在测试过程中发现，如果不先在前台手动执行一次collectd，直接用<code>systemctl start collectd</code>启动服务会导致其一直报错。执行以下指令可以让collectd在前台执行：<br><code>/usr/sbin/collectd -f</code><br>如果没有问题的话就<code>ctrl+c</code>结束程序。</p><h2 id="五-服务运行与开机自启动"><a href="#五-服务运行与开机自启动" class="headerlink" title="五.  服务运行与开机自启动"></a>五.  服务运行与开机自启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start influxdb</span><br><span class="line">systemctl <span class="built_in">enable</span> influxdb</span><br></pre></td></tr></table></figure><h2 id="六-测试"><a href="#六-测试" class="headerlink" title="六. 测试"></a>六. 测试</h2><p>通过influx shell查看数据库collectd数据库，一切正常的话，里面会出现名为cpu_value的measurement。这说明collectd的cpu组件已经在不停地往influxdb写入数据了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> collectd </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>influxdb的部署</title>
      <link href="/2017/09/30/influxdb-deploy/"/>
      <url>/2017/09/30/influxdb-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>influxdb是目前比较流行的时间序列数据库，本文只介绍如何部署influxdb，具体知识点请查阅相关资料。</p><h2 id="一-下载安装"><a href="#一-下载安装" class="headerlink" title="一. 下载安装"></a>一. 下载安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.3.5.x86_64.rpm</span><br><span class="line">yum localinstall influxdb-1.3.5.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="二-服务的运行和开机自启动"><a href="#二-服务的运行和开机自启动" class="headerlink" title="二. 服务的运行和开机自启动"></a>二. 服务的运行和开机自启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start influxdb</span><br><span class="line">systemctl <span class="built_in">enable</span> influxdb</span><br></pre></td></tr></table></figure><h2 id="三-使用influx-shell与influxdb进行交互，创建一个管理员账号"><a href="#三-使用influx-shell与influxdb进行交互，创建一个管理员账号" class="headerlink" title="三. 使用influx shell与influxdb进行交互，创建一个管理员账号"></a>三. 使用influx shell与influxdb进行交互，创建一个管理员账号</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">influx</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> admin <span class="keyword">with</span> password <span class="string">&#x27;admin&#x27;</span> <span class="keyword">with</span> <span class="keyword">all</span> privileges <span class="keyword">to</span> admin;</span><br></pre></td></tr></table></figure><h2 id="四-修改配置文件启用权限认证"><a href="#四-修改配置文件启用权限认证" class="headerlink" title="四. 修改配置文件启用权限认证"></a>四. 修改配置文件启用权限认证</h2><ol><li>编辑/etc/influxdb/influxdb.conf文件，将<code>[http]</code>下的<code>auth-enabled</code>修改为<code>true</code>，然后重启服务。</li><li>以后每次登陆influxdb shell，执行指令前都需要先执行<code>auth</code>指令通过身份认证。</li></ol><h2 id="五-修改默认端口"><a href="#五-修改默认端口" class="headerlink" title="五. 修改默认端口"></a>五. 修改默认端口</h2><ol><li>编辑/etc/influxdb/influxdb.conf文件，将<code>[http]</code>下的<code>bind-address = &quot;:8086&quot;</code>中的<code>8086</code>修改为<code>8087</code>，改完后重启服务。</li><li>换了端口后，进入influx shell的指令就变为了<code>influx -port 8087</code></li></ol><h2 id="六-测试"><a href="#六-测试" class="headerlink" title="六. 测试"></a>六. 测试</h2><ol><li>先通过influx shell执行一条创建数据库的语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database testDb;</span><br></pre></td></tr></table></figure></li><li>在bash中通过curl进行一次post请求：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST <span class="string">&quot;http://localhost:8087/write?db=testDb&amp;u=admin&amp;p=admin&quot;</span> --data-binary <span class="string">&quot;testMetric,host=mbp value=0.64&quot;</span></span><br><span class="line"><span class="comment">#这里的`db=testDb`就是数据库，`u=admin`和`p=admin`分别是第三步中设置的用户名和密码，`testMetric`是度量，`host=mbp`是标签，`value=0.64`是数据</span></span><br></pre></td></tr></table></figure></li><li>在influx shell中执行查询语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use testDb; <span class="operator">/</span><span class="operator">/</span>使用testDb数据库</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testMetric; <span class="operator">/</span><span class="operator">/</span>查询度量testMetric</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> influxdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql配置与运行状态的分析与优化</title>
      <link href="/2017/08/15/mysql-optimize/"/>
      <url>/2017/08/15/mysql-optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h2><p>mysql&gt; show variables;//查看mysql具体配置</p><p>mysql&gt; show global status;//查看mysql运行状态</p><p>配置是写在my.cnf里面的，而状态是具体执行时的指标</p><h2 id="慢查："><a href="#慢查：" class="headerlink" title="慢查："></a>慢查：</h2><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><p>slow_launch_time：2 //执行时间超过2秒就会被记录为慢查</p><p>slow_query_log：ON //慢查会被记录</p><p>slow_query_log_file：iZ23qcdbhgiZ-slow.log //慢查日志文件名</p><h4 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h4><p>slow_launch_threads：0 //创建时间超过slow_launch_time秒的线程数</p><p>slow_queries：0 //慢查个数</p><h2 id="最大连接数："><a href="#最大连接数：" class="headerlink" title="最大连接数："></a>最大连接数：</h2><h4 id="配置：-1"><a href="#配置：-1" class="headerlink" title="配置："></a>配置：</h4><p>max_connections：256 //允许的最大连接数</p><h4 id="状态：-1"><a href="#状态：-1" class="headerlink" title="状态："></a>状态：</h4><p>max_used_connections：123 //实际运行中的最大连接数</p><h4 id="期望："><a href="#期望：" class="headerlink" title="期望："></a>期望：</h4><p>max_used_connections / max_connections * 100% ≈ 85%</p><h2 id="索引缓存-对MyISAM性能影响很大"><a href="#索引缓存-对MyISAM性能影响很大" class="headerlink" title="索引缓存(对MyISAM性能影响很大)"></a>索引缓存(对MyISAM性能影响很大)</h2><h4 id="配置：-2"><a href="#配置：-2" class="headerlink" title="配置："></a>配置：</h4><p>key_buffer_size：134217728 //索引缓存大小</p><h4 id="状态：-2"><a href="#状态：-2" class="headerlink" title="状态："></a>状态：</h4><p>key_read_requests：123 //索引读取请求个数</p><p>Key_reads： 123 //没有命中缓存而去硬盘读取的次数</p><p>Key_blocks_unused：123 //未使用的缓存簇(blocks)数</p><p>Key_blocks_used： //曾经用到的最大的blocks数</p><h4 id="期望：-1"><a href="#期望：-1" class="headerlink" title="期望："></a>期望：</h4><p>key_reads / key_read_requests * 100% &lt; 0.1%</p><p>key_blocks_used / (key_blocks_unused + key_blocks_used) * 100% ≈ 80%</p><h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><h4 id="配置：-3"><a href="#配置：-3" class="headerlink" title="配置："></a>配置：</h4><p>max_heap_table_size：16777216 //内存表的最大大小</p><p>tmp_table_size：16777216 //内存临时表最大大小</p><h4 id="状态：-3"><a href="#状态：-3" class="headerlink" title="状态："></a>状态：</h4><p>Created_tmp_disk_tables：0 //创建(内存或磁盘)临时表的次数</p><p>Created_tmp_files：6 //临时文件个数 </p><p>Created_tmp_tables：22 //创建磁盘临时表的次数</p><h4 id="期望：-2"><a href="#期望：-2" class="headerlink" title="期望："></a>期望：</h4><p>理想#### 状态：created_tmp_disk_tables / created_tmp_tables * 100% &lt;= 25%</p><p>备注：</p><p>当查询需要使用临时表的时候，系统会优先创建内存临时表(MEMORY引擎)。但如果内存临时表大小超过了max_heap_table_size或者tmp_table_size，它就会转为磁盘临时表(MyISAM引擎)。</p><h2 id="表缓存"><a href="#表缓存" class="headerlink" title="表缓存"></a>表缓存</h2><h4 id="配置：-4"><a href="#配置：-4" class="headerlink" title="配置："></a>配置：</h4><p>table_cache(table_open_cache)： 3//缓存的打开的表的数量</p><h4 id="状态：-4"><a href="#状态：-4" class="headerlink" title="状态："></a>状态：</h4><p>open_tables：1 //打开表的数量</p><p>opened_tables： 2//表示打开过的表数量</p><h4 id="期望：-3"><a href="#期望：-3" class="headerlink" title="期望："></a>期望：</h4><p>Open_tables / Opened_tables * 100% &gt;= 85%</p><p>Open_tables / table_cache * 100% &lt;= 95%</p><h2 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h2><h4 id="配置：-5"><a href="#配置：-5" class="headerlink" title="配置："></a>配置：</h4><p>thread_cache_size：13 //服务器缓存的用来处理用户查询的线程</p><h4 id="状态：-5"><a href="#状态：-5" class="headerlink" title="状态："></a>状态：</h4><p>threads_created：12 //表示创建过的线程数</p><h2 id="文件打开数"><a href="#文件打开数" class="headerlink" title="文件打开数"></a>文件打开数</h2><h4 id="配置：-6"><a href="#配置：-6" class="headerlink" title="配置："></a>配置：</h4><p>open_files_limit：1024 //允许同时打开的最大文件数</p><h4 id="状态：-6"><a href="#状态：-6" class="headerlink" title="状态："></a>状态：</h4><p>open_files：123 //当前打开的文件数</p><h4 id="期望：-4"><a href="#期望：-4" class="headerlink" title="期望："></a>期望：</h4><p>open_files / open_files_limit * 100% &lt;= 75％</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h4 id="状态：-7"><a href="#状态：-7" class="headerlink" title="状态："></a>状态：</h4><p>table_locks_immediate： 123//立即释放表锁数</p><p>table_locks_waited： 456//需要等待的表锁数</p><h4 id="期望：-5"><a href="#期望：-5" class="headerlink" title="期望："></a>期望：</h4><p>table_locks_immediate / table_locks_waited &gt; 5000 时推荐使用高并发更新性能好的innodb引擎</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
